<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <title>E-NOR Controller</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    body {
      background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 100%);
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    #header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 12px;
      background: rgba(0,0,0,0.3);
      border-bottom: 1px solid #333;
      flex-shrink: 0;
    }

    #status {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
    }

    #status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ff4444;
    }

    #status-dot.connected {
      background: #00ff00;
    }

    #title {
      font-size: 16px;
      font-weight: bold;
      color: #00ffff;
    }

    #speed-control {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
    }

    #speed-slider {
      width: 60px;
      accent-color: #00ffff;
    }

    /* Main controller area */
    #controller {
      flex: 1;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 15px;
      gap: 10px;
      min-height: 0;
    }

    /* Joystick area */
    #joystick-container {
      width: 150px;
      height: 150px;
      background: rgba(255,255,255,0.05);
      border-radius: 50%;
      border: 3px solid #00ffff;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-shrink: 0;
    }

    #joystick {
      width: 60px;
      height: 60px;
      background: radial-gradient(circle at 30% 30%, #00ffff, #0088aa);
      border-radius: 50%;
      position: absolute;
      box-shadow: 0 4px 15px rgba(0,255,255,0.4);
    }

    #joystick.active {
      background: radial-gradient(circle at 30% 30%, #00ff88, #00aa66);
      box-shadow: 0 4px 20px rgba(0,255,136,0.6);
    }

    /* Center section - emotions & stop */
    #center-section {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
    }

    #current-direction {
      font-size: 20px;
      font-weight: bold;
      color: #00ffff;
      text-transform: uppercase;
      min-height: 24px;
    }

    #stop-btn {
      width: 90px;
      height: 90px;
      border-radius: 50%;
      background: linear-gradient(145deg, #ff4444, #cc0000);
      border: 4px solid #ff6666;
      color: white;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 6px 20px rgba(255,0,0,0.4);
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #stop-btn:active {
      transform: scale(0.95);
      box-shadow: 0 2px 10px rgba(255,0,0,0.4);
    }

    /* Emotion grid */
    #emotion-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
    }

    .emotion-btn {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      border: 2px solid #444;
      background: rgba(255,255,255,0.1);
      font-size: 20px;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .emotion-btn:active {
      transform: scale(0.9);
      border-color: #00ffff;
    }

    /* Action buttons (right side) */
    #action-section {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .action-row {
      display: flex;
      gap: 8px;
      justify-content: center;
    }

    .action-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: 3px solid;
      font-size: 12px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 1px;
    }

    .action-btn .icon {
      font-size: 18px;
    }

    .action-btn .label {
      font-size: 8px;
      opacity: 0.8;
    }

    .action-btn:active {
      transform: scale(0.9);
    }

    #btn-y {
      background: linear-gradient(145deg, #ffcc00, #cc9900);
      border-color: #ffdd44;
      color: #000;
    }

    #btn-x {
      background: linear-gradient(145deg, #0088ff, #0055cc);
      border-color: #44aaff;
      color: #fff;
    }

    #btn-b {
      background: linear-gradient(145deg, #ff4444, #cc0000);
      border-color: #ff6666;
      color: #fff;
    }

    #btn-a {
      background: linear-gradient(145deg, #00cc44, #008833);
      border-color: #44ff66;
      color: #fff;
    }

    #btn-a.dancing {
      animation: pulse 0.3s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    /* D-Pad alternative (shown on toggle) */
    #dpad-container {
      display: none;
      width: 150px;
      height: 150px;
      position: relative;
      flex-shrink: 0;
    }

    #dpad-container.visible {
      display: block;
    }

    #joystick-container.hidden {
      display: none;
    }

    .dpad-btn {
      position: absolute;
      width: 50px;
      height: 50px;
      background: rgba(0,255,255,0.2);
      border: 2px solid #00ffff;
      border-radius: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      color: #00ffff;
    }

    .dpad-btn:active {
      background: rgba(0,255,255,0.5);
    }

    #dpad-up { top: 0; left: 50%; transform: translateX(-50%); }
    #dpad-down { bottom: 0; left: 50%; transform: translateX(-50%); }
    #dpad-left { left: 0; top: 50%; transform: translateY(-50%); }
    #dpad-right { right: 0; top: 50%; transform: translateY(-50%); }

    /* Toggle control type */
    #control-toggle {
      position: absolute;
      bottom: 8px;
      left: 8px;
      padding: 6px 10px;
      background: rgba(255,255,255,0.1);
      border: 1px solid #444;
      border-radius: 20px;
      color: #888;
      font-size: 10px;
      cursor: pointer;
    }

    #control-toggle:active {
      background: rgba(255,255,255,0.2);
    }

    /* Landscape prompt */
    #rotate-prompt {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.95);
      justify-content: center;
      align-items: center;
      flex-direction: column;
      gap: 20px;
      z-index: 1000;
    }

    #rotate-prompt .icon {
      font-size: 60px;
      animation: rotate-hint 2s ease-in-out infinite;
    }

    @keyframes rotate-hint {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(90deg); }
    }

    @media (orientation: portrait) {
      #rotate-prompt {
        display: flex;
      }
    }

    /* Quick actions bar */
    #quick-actions {
      display: flex;
      justify-content: center;
      gap: 6px;
      padding: 6px 10px;
      background: rgba(0,0,0,0.3);
      border-top: 1px solid #333;
      flex-shrink: 0;
      flex-wrap: wrap;
    }

    .quick-btn {
      padding: 6px 10px;
      background: rgba(255,255,255,0.1);
      border: 1px solid #444;
      border-radius: 6px;
      color: #fff;
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
      white-space: nowrap;
    }

    .quick-btn:active {
      background: rgba(255,255,255,0.2);
      border-color: #00ffff;
    }

    .quick-btn .icon {
      font-size: 14px;
    }

    /* Tap to start overlay */
    #tap-to-start {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      gap: 20px;
      z-index: 999;
      cursor: pointer;
    }

    #tap-to-start.hidden {
      display: none;
    }

    #tap-to-start .title {
      font-size: 32px;
      color: #00ffff;
      font-weight: bold;
    }

    #tap-to-start .subtitle {
      font-size: 18px;
      color: #888;
      animation: blink 1.5s infinite;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    /* Modal styles */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.85);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .modal.hidden {
      display: none;
    }

    .modal-content {
      background: linear-gradient(135deg, #1a1a3a 0%, #2a2a4a 100%);
      border: 2px solid #00ffff;
      border-radius: 16px;
      padding: 20px;
      max-width: 90%;
      max-height: 80%;
      overflow-y: auto;
    }

    .modal-content h3 {
      color: #00ffff;
      margin: 0 0 15px 0;
      text-align: center;
    }

    .modal-close {
      width: 100%;
      padding: 12px;
      margin-top: 15px;
      background: rgba(255,255,255,0.1);
      border: 1px solid #444;
      border-radius: 8px;
      color: #fff;
      font-size: 14px;
      cursor: pointer;
    }

    .modal-close:active {
      background: rgba(255,255,255,0.2);
    }

    .game-btn {
      width: 100%;
      padding: 15px;
      margin: 8px 0;
      background: rgba(0,255,255,0.1);
      border: 1px solid #00ffff;
      border-radius: 8px;
      color: #fff;
      font-size: 16px;
      text-align: left;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .game-btn:active {
      background: rgba(0,255,255,0.3);
    }

    .game-btn .emoji {
      font-size: 24px;
    }

    .game-btn .name {
      flex: 1;
    }

    /* Extension buttons in quick actions */
    #extension-buttons {
      display: contents;
    }

    /* Voice mode active indicator */
    .action-btn.voice-active {
      animation: voicePulse 1s infinite;
    }

    @keyframes voicePulse {
      0%, 100% { box-shadow: 0 0 10px rgba(0,255,0,0.5); }
      50% { box-shadow: 0 0 20px rgba(0,255,0,0.8); }
    }

    /* Mode active indicator */
    .action-btn.mode-active {
      animation: modePulse 1.5s infinite;
    }

    @keyframes modePulse {
      0%, 100% { box-shadow: 0 0 10px rgba(255,100,100,0.5); }
      50% { box-shadow: 0 0 20px rgba(255,100,100,0.8); }
    }
  </style>
</head>
<body>
  <!-- Tap to start (auto fullscreen) -->
  <div id="tap-to-start" onclick="startController()">
    <div class="title">E-NOR Controller</div>
    <div class="subtitle">Tap anywhere to start</div>
  </div>

  <!-- Rotate prompt for portrait mode -->
  <div id="rotate-prompt">
    <div class="icon">üì±</div>
    <div>Rotate your phone to landscape mode</div>
  </div>

  <!-- Header -->
  <div id="header">
    <div id="status">
      <div id="status-dot"></div>
      <span id="status-text">Connecting...</span>
    </div>
    <div id="title">E-NOR</div>
    <div id="speed-control">
      <span>Speed:</span>
      <input type="range" id="speed-slider" min="30" max="100" value="70">
      <span id="speed-value">70%</span>
    </div>
  </div>

  <!-- Main controller -->
  <div id="controller">
    <!-- Left: Joystick or D-Pad -->
    <div id="joystick-container">
      <div id="joystick"></div>
    </div>
    <div id="dpad-container">
      <button class="dpad-btn" id="dpad-up">‚ñ≤</button>
      <button class="dpad-btn" id="dpad-down">‚ñº</button>
      <button class="dpad-btn" id="dpad-left">‚óÑ</button>
      <button class="dpad-btn" id="dpad-right">‚ñ∫</button>
    </div>

    <!-- Center: Stop button & current state -->
    <div id="center-section">
      <div id="current-direction">-</div>
      <button id="stop-btn" ontouchstart="emergencyStop()" onclick="emergencyStop()">STOP</button>
      <div id="emotion-grid">
        <button class="emotion-btn" onclick="setEmotion('happy')">üòä</button>
        <button class="emotion-btn" onclick="setEmotion('surprised')">üòÆ</button>
        <button class="emotion-btn" onclick="setEmotion('sad')">üò¢</button>
        <button class="emotion-btn" onclick="setEmotion('angry')">üò†</button>
      </div>
    </div>

    <!-- Right: Action buttons -->
    <div id="action-section">
      <div class="action-row">
        <button class="action-btn" id="btn-y" ontouchstart="actionY()" onclick="actionY()">
          <span class="icon">üí¨</span>
          <span class="label">SPEAK</span>
        </button>
      </div>
      <div class="action-row">
        <button class="action-btn" id="btn-x" ontouchstart="actionX()" onclick="actionX()">
          <span class="icon">üòÇ</span>
          <span class="label">JOKE</span>
        </button>
        <button class="action-btn" id="btn-b" ontouchstart="actionB()" onclick="actionB()">
          <span class="icon">üé≠</span>
          <span class="label">MODE</span>
        </button>
      </div>
      <div class="action-row">
        <button class="action-btn" id="btn-a" ontouchstart="actionA()" onclick="actionA()">
          <span class="icon">üéâ</span>
          <span class="label">DISCO</span>
        </button>
      </div>
    </div>
  </div>

  <!-- Quick actions bar -->
  <div id="quick-actions">
    <button class="quick-btn" onclick="speak('Hello!')">
      <span class="icon">üëã</span> Hello
    </button>
    <button class="quick-btn" onclick="speak('I love you!')">
      <span class="icon">‚ù§Ô∏è</span> Love
    </button>
    <button class="quick-btn" onclick="showGamesList()">
      <span class="icon">üéÆ</span> Play
    </button>
    <button class="quick-btn" onclick="playHonk()">
      <span class="icon">üìØ</span> Honk
    </button>
    <!-- Extension buttons will be added here dynamically -->
    <div id="extension-buttons"></div>
  </div>

  <!-- Games list modal -->
  <div id="games-modal" class="modal hidden">
    <div class="modal-content">
      <h3>Choose a Game</h3>
      <div id="games-list"></div>
      <button class="modal-close" onclick="hideGamesList()">Cancel</button>
    </div>
  </div>

  <!-- Control type toggle -->
  <button id="control-toggle" onclick="toggleControlType()">D-Pad</button>

  <script>
    // WebSocket connection
    let ws = null;
    let connected = false;
    let speed = 0.7;
    let currentDirection = null;
    let useDpad = false;
    let isDancing = false;
    let danceInterval = null;
    let wakeLock = null;
    let voiceModeActive = false;
    let availableModes = [];
    let currentModeIndex = -1;
    let availableGames = [];
    let extensionButtons = [];

    // DOM elements
    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');
    const joystickContainer = document.getElementById('joystick-container');
    const joystick = document.getElementById('joystick');
    const dpadContainer = document.getElementById('dpad-container');
    const directionDisplay = document.getElementById('current-direction');
    const speedSlider = document.getElementById('speed-slider');
    const speedValue = document.getElementById('speed-value');
    const controlToggle = document.getElementById('control-toggle');
    const tapToStart = document.getElementById('tap-to-start');
    const btnA = document.getElementById('btn-a');

    // Joystick state
    let joystickActive = false;
    let joystickCenter = { x: 0, y: 0 };
    const joystickRadius = 45; // Max movement radius

    // Start controller (fullscreen + init)
    async function startController() {
      tapToStart.classList.add('hidden');

      // Go fullscreen
      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen().catch(err => {
          console.log('Fullscreen not available:', err);
        });
      }

      // Keep screen on with Wake Lock API
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
          console.log('Wake lock active - screen will stay on');
        }
      } catch (err) {
        console.log('Wake lock not available:', err);
      }

      // Initialize after a short delay to let fullscreen settle
      setTimeout(() => {
        initJoystick();
        initDpad();
      }, 100);
    }

    // Re-acquire wake lock if page becomes visible again
    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState === 'visible' && !wakeLock) {
        try {
          if ('wakeLock' in navigator) {
            wakeLock = await navigator.wakeLock.request('screen');
            console.log('Wake lock re-acquired');
          }
        } catch (err) {
          console.log('Could not re-acquire wake lock:', err);
        }
      }
    });

    // Connect WebSocket
    function connect() {
      const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${protocol}//${location.host}/ws`);

      ws.onopen = () => {
        connected = true;
        statusDot.classList.add('connected');
        statusText.textContent = 'Connected';
        console.log('Connected to E-NOR');
      };

      ws.onclose = () => {
        connected = false;
        statusDot.classList.remove('connected');
        statusText.textContent = 'Disconnected';
        console.log('Disconnected - reconnecting...');
        setTimeout(connect, 2000);
      };

      ws.onerror = (err) => {
        console.error('WebSocket error:', err);
      };

      ws.onmessage = (event) => {
        try {
          const msg = JSON.parse(event.data);
          // Handle any responses if needed
        } catch (e) {}
      };
    }

    function send(data) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(data));
      }
    }

    // Motor control
    function sendMotorCommand(direction, motorSpeed = null) {
      const s = motorSpeed !== null ? motorSpeed : speed;
      currentDirection = direction;
      directionDisplay.textContent = direction || '-';

      fetch(`/api/motor/${direction}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ speed: s })
      }).catch(err => console.error('Motor command failed:', err));
    }

    function sendStop() {
      currentDirection = null;
      directionDisplay.textContent = '-';
      fetch('/api/motor/stop', { method: 'POST' })
        .catch(err => console.error('Stop failed:', err));

      // Haptic feedback
      if (navigator.vibrate) {
        navigator.vibrate(50);
      }
    }

    // Emergency stop - stops everything and resets to happy mode
    async function emergencyStop() {
      console.log('EMERGENCY STOP activated');

      // Stop motors immediately
      currentDirection = null;
      directionDisplay.textContent = 'STOPPING';
      await fetch('/api/motor/stop', { method: 'POST' })
        .catch(err => console.error('Motor stop failed:', err));

      // Cancel any motor sequences
      await fetch('/api/motor/cancel', { method: 'POST' })
        .catch(err => console.error('Sequence cancel failed:', err));

      // Stop dancing if active
      if (isDancing) {
        stopDancing();
      }

      // Reset mode to none
      if (currentModeIndex >= 0 && availableModes.length > 0) {
        const currentMode = availableModes[currentModeIndex];
        send({ type: 'set_mode', mode: currentMode.id, enabled: false });
        if (currentMode.has_overlay) {
          send({ type: 'hide_overlay', overlay_id: currentMode.id });
        }
      }
      currentModeIndex = -1;
      const btnB = document.getElementById('btn-b');
      btnB.classList.remove('mode-active');
      btnB.querySelector('.label').textContent = 'MODE';

      // Stop voice mode if active
      if (voiceModeActive) {
        voiceModeActive = false;
        const btnY = document.getElementById('btn-y');
        btnY.classList.remove('voice-active');
        btnY.querySelector('.label').textContent = 'SPEAK';
        send({ type: 'stop_voice_mode' });
      }

      // Reset to happy emotion
      setEmotion('happy');

      // Hide any overlays
      send({ type: 'hide_overlay' });

      // Close any open panels
      send({ type: 'close_panel' });

      // Broadcast full emergency stop
      send({ type: 'emergency_stop' });

      // Update display
      directionDisplay.textContent = 'STOPPED';

      // Haptic feedback - strong vibration pattern
      if (navigator.vibrate) {
        navigator.vibrate([100, 50, 100, 50, 100]);
      }

      // Reset display after 1 second
      setTimeout(() => {
        directionDisplay.textContent = '-';
      }, 1000);

      console.log('Emergency stop complete - reset to happy mode');
    }

    // Joystick handling
    function initJoystick() {
      const rect = joystickContainer.getBoundingClientRect();
      joystickCenter = {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      };

      joystickContainer.addEventListener('touchstart', handleJoystickStart, { passive: false });
      joystickContainer.addEventListener('touchmove', handleJoystickMove, { passive: false });
      joystickContainer.addEventListener('touchend', handleJoystickEnd, { passive: false });
      joystickContainer.addEventListener('touchcancel', handleJoystickEnd, { passive: false });
    }

    function handleJoystickStart(e) {
      e.preventDefault();
      joystickActive = true;
      joystick.classList.add('active');

      // Recalculate center in case of scroll/resize
      const rect = joystickContainer.getBoundingClientRect();
      joystickCenter = {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      };

      handleJoystickMove(e);
    }

    function handleJoystickMove(e) {
      if (!joystickActive) return;
      e.preventDefault();

      const touch = e.touches[0];
      let dx = touch.clientX - joystickCenter.x;
      let dy = touch.clientY - joystickCenter.y;

      // Clamp to radius
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance > joystickRadius) {
        dx = (dx / distance) * joystickRadius;
        dy = (dy / distance) * joystickRadius;
      }

      // Update joystick position
      joystick.style.transform = `translate(${dx}px, ${dy}px)`;

      // Calculate direction and speed
      const normalizedDistance = Math.min(distance / joystickRadius, 1);
      const angle = Math.atan2(dy, dx) * (180 / Math.PI);

      // Very small dead zone for better sensitivity
      if (normalizedDistance < 0.08) {
        if (currentDirection !== null) {
          sendStop();
        }
        return;
      }

      // Calculate motor speed - use full speed even at smaller distances
      const motorSpeed = speed * Math.max(0.5, normalizedDistance);

      // Determine direction based on angle
      let newDirection;
      if (angle >= -45 && angle < 45) {
        newDirection = 'right';
      } else if (angle >= 45 && angle < 135) {
        newDirection = 'backward';
      } else if (angle >= -135 && angle < -45) {
        newDirection = 'forward';
      } else {
        newDirection = 'left';
      }

      // Always send command to ensure motor responds
      if (currentDirection !== newDirection) {
        sendMotorCommand(newDirection, motorSpeed);
      }
    }

    function handleJoystickEnd(e) {
      e.preventDefault();
      joystickActive = false;
      joystick.classList.remove('active');
      joystick.style.transform = 'translate(0, 0)';
      sendStop();
    }

    // D-Pad handling
    function initDpad() {
      ['up', 'down', 'left', 'right'].forEach(dir => {
        const btn = document.getElementById(`dpad-${dir}`);
        const motorDir = dir === 'up' ? 'forward' : dir === 'down' ? 'backward' : dir;

        btn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          sendMotorCommand(motorDir);
          if (navigator.vibrate) navigator.vibrate(30);
        }, { passive: false });

        btn.addEventListener('touchend', (e) => {
          e.preventDefault();
          sendStop();
        }, { passive: false });

        btn.addEventListener('touchcancel', (e) => {
          e.preventDefault();
          sendStop();
        }, { passive: false });
      });
    }

    // Toggle between joystick and d-pad
    function toggleControlType() {
      useDpad = !useDpad;
      if (useDpad) {
        joystickContainer.classList.add('hidden');
        dpadContainer.classList.add('visible');
        controlToggle.textContent = 'Joystick';
      } else {
        joystickContainer.classList.remove('hidden');
        dpadContainer.classList.remove('visible');
        controlToggle.textContent = 'D-Pad';
      }
      // Recalculate joystick center after toggle
      setTimeout(() => {
        const rect = joystickContainer.getBoundingClientRect();
        joystickCenter = {
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2
        };
      }, 100);
    }

    // Speed control
    speedSlider.addEventListener('input', () => {
      speed = speedSlider.value / 100;
      speedValue.textContent = `${speedSlider.value}%`;
    });

    // Emotion control
    function setEmotion(emotion) {
      send({ type: 'emotion', emotion: emotion });
      if (navigator.vibrate) navigator.vibrate(30);
    }

    // Disco dance routine
    function startDancing() {
      if (isDancing) return;
      isDancing = true;
      btnA.classList.add('dancing');

      send({ type: 'disco', enabled: true });

      let danceStep = 0;
      const danceSpeed = 0.6;

      function doDanceMove() {
        if (!isDancing) return;

        // Randomize timing a bit (200-400ms)
        const nextDelay = 200 + Math.random() * 200;

        // Randomize direction (mostly left/right, occasional forward wiggle)
        const rand = Math.random();
        let direction;
        if (rand < 0.4) {
          direction = 'left';
        } else if (rand < 0.8) {
          direction = 'right';
        } else if (rand < 0.9) {
          direction = 'forward';
        } else {
          direction = 'backward';
        }

        // Randomize speed a bit
        const moveSpeed = danceSpeed + (Math.random() * 0.3 - 0.15);

        sendMotorCommand(direction, moveSpeed);
        directionDisplay.textContent = 'üï∫ ' + direction;

        danceStep++;
        danceInterval = setTimeout(doDanceMove, nextDelay);
      }

      doDanceMove();

      // Stop after 5 seconds
      setTimeout(stopDancing, 5000);
    }

    function stopDancing() {
      isDancing = false;
      btnA.classList.remove('dancing');
      if (danceInterval) {
        clearTimeout(danceInterval);
        danceInterval = null;
      }
      sendStop();
      send({ type: 'disco', enabled: false });
    }

    // Action buttons
    function actionA() {
      if (isDancing) {
        stopDancing();
      } else {
        startDancing();
      }
      if (navigator.vibrate) navigator.vibrate([50, 50, 50]);
    }

    function actionB() {
      // Cycle through available modes
      cycleMode();
      if (navigator.vibrate) navigator.vibrate([50, 50, 50]);
    }

    function actionX() {
      // Generate an original joke via Claude API
      generateOriginalJoke();
      if (navigator.vibrate) navigator.vibrate(30);
    }

    function actionY() {
      // Toggle voice mode on E-NOR
      toggleVoiceMode();
      if (navigator.vibrate) navigator.vibrate([50, 50, 50]);
    }

    // Toggle voice mode on the main UI
    async function toggleVoiceMode() {
      voiceModeActive = !voiceModeActive;
      const btnY = document.getElementById('btn-y');

      if (voiceModeActive) {
        btnY.classList.add('voice-active');
        btnY.querySelector('.label').textContent = 'LISTENING';
        // Tell main UI to start voice mode
        send({ type: 'start_voice_mode' });
      } else {
        btnY.classList.remove('voice-active');
        btnY.querySelector('.label').textContent = 'SPEAK';
        // Tell main UI to stop voice mode
        send({ type: 'stop_voice_mode' });
      }
    }

    // Cycle through available modes
    async function cycleMode() {
      // Fetch modes if we don't have them
      if (availableModes.length === 0) {
        try {
          const response = await fetch('/api/extensions/modes');
          const data = await response.json();
          availableModes = data.modes || [];
        } catch (e) {
          console.error('Failed to fetch modes:', e);
          speak("Sorry, I couldn't load the modes.");
          return;
        }
      }

      if (availableModes.length === 0) {
        speak("I don't have any modes installed yet!");
        return;
      }

      const btnB = document.getElementById('btn-b');

      // If we have an active mode, deactivate it first
      if (currentModeIndex >= 0) {
        const currentMode = availableModes[currentModeIndex];
        send({ type: 'set_mode', mode: currentMode.id, enabled: false });

        // Hide overlays for current mode
        if (currentMode.has_overlay) {
          send({ type: 'hide_overlay', overlay_id: currentMode.id });
        }
      }

      // Move to next mode (or back to no mode if at end)
      currentModeIndex++;

      if (currentModeIndex >= availableModes.length) {
        // Reset to no mode
        currentModeIndex = -1;
        btnB.classList.remove('mode-active');
        btnB.querySelector('.label').textContent = 'MODE';
        setEmotion('happy');
        speak("Back to normal mode!");
        return;
      }

      // Activate the new mode
      const newMode = availableModes[currentModeIndex];
      btnB.classList.add('mode-active');
      btnB.querySelector('.label').textContent = newMode.name.toUpperCase();

      send({ type: 'set_mode', mode: newMode.id, enabled: true });

      // Show overlays for new mode
      if (newMode.has_overlay) {
        send({ type: 'show_overlay', overlay_id: newMode.id });
      }

      // Announce the mode
      speak(`${newMode.name} activated!`);
    }

    // Generate an original joke via Claude
    async function generateOriginalJoke() {
      setEmotion('thinking');
      speak("Let me think of a joke...");

      try {
        const response = await fetch('/api/controller/generate-joke', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });

        if (response.ok) {
          const data = await response.json();
          setEmotion('happy');
          speak(data.joke);
        } else {
          // Fallback to a random joke
          const jokes = [
            "Why don't scientists trust atoms? Because they make up everything!",
            "What do you call a bear with no teeth? A gummy bear!",
            "Why did the bicycle fall over? Because it was two tired!"
          ];
          setEmotion('happy');
          speak(jokes[Math.floor(Math.random() * jokes.length)]);
        }
      } catch (e) {
        console.error('Failed to generate joke:', e);
        setEmotion('happy');
        speak("Why did the robot go to therapy? It had too many bugs!");
      }
    }

    // Play honk sound through Web Audio API
    function playHonk() {
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // Create a honk-like sound using oscillators
      const now = audioCtx.currentTime;

      // Main honk tone
      const osc1 = audioCtx.createOscillator();
      const gain1 = audioCtx.createGain();
      osc1.type = 'sawtooth';
      osc1.frequency.setValueAtTime(200, now);
      osc1.frequency.exponentialRampToValueAtTime(150, now + 0.3);
      gain1.gain.setValueAtTime(0.5, now);
      gain1.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
      osc1.connect(gain1);
      gain1.connect(audioCtx.destination);
      osc1.start(now);
      osc1.stop(now + 0.4);

      // Secondary tone for richness
      const osc2 = audioCtx.createOscillator();
      const gain2 = audioCtx.createGain();
      osc2.type = 'square';
      osc2.frequency.setValueAtTime(180, now);
      osc2.frequency.exponentialRampToValueAtTime(140, now + 0.3);
      gain2.gain.setValueAtTime(0.3, now);
      gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
      osc2.connect(gain2);
      gain2.connect(audioCtx.destination);
      osc2.start(now);
      osc2.stop(now + 0.35);

      // Also broadcast to main UI
      send({ type: 'play_honk' });

      if (navigator.vibrate) navigator.vibrate(100);
    }

    // Show games list modal
    async function showGamesList() {
      try {
        const response = await fetch('/api/extensions/category/games');
        const data = await response.json();
        availableGames = data.extensions || [];

        const gamesList = document.getElementById('games-list');
        const modal = document.getElementById('games-modal');

        if (availableGames.length === 0) {
          gamesList.innerHTML = '<p style="color: #888; text-align: center;">No games installed yet!</p>';
        } else {
          gamesList.innerHTML = availableGames.map(game => `
            <button class="game-btn" onclick="launchGame('${game.id}')">
              <span class="emoji">${game.ui?.button_emoji || 'üéÆ'}</span>
              <span class="name">${game.name}</span>
            </button>
          `).join('');
        }

        modal.classList.remove('hidden');
      } catch (e) {
        console.error('Failed to fetch games:', e);
        speak("Sorry, I couldn't load the games list.");
      }
    }

    // Hide games list modal
    function hideGamesList() {
      document.getElementById('games-modal').classList.add('hidden');
    }

    // Launch a game
    async function launchGame(gameId) {
      hideGamesList();

      try {
        const response = await fetch('/api/controller/launch-game', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ game_id: gameId })
        });

        if (response.ok) {
          speak("Let's play!");
        } else {
          speak("Sorry, I couldn't start the game.");
        }
      } catch (e) {
        console.error('Failed to launch game:', e);
        speak("Sorry, something went wrong.");
      }
    }

    // Load extension buttons
    async function loadExtensionButtons() {
      try {
        const response = await fetch('/api/controller/extension-buttons');
        const data = await response.json();
        extensionButtons = data.buttons || [];

        const container = document.getElementById('extension-buttons');
        container.innerHTML = extensionButtons.map(btn => `
          <button class="quick-btn" onclick="triggerExtensionButton('${btn.extension_id}', '${btn.action}')">
            <span class="icon">${btn.emoji || '‚ö°'}</span> ${btn.label}
          </button>
        `).join('');
      } catch (e) {
        console.error('Failed to load extension buttons:', e);
      }
    }

    // Trigger an extension button action
    function triggerExtensionButton(extensionId, action) {
      send({ type: 'run_extension', extension_id: extensionId, action: action });
      if (navigator.vibrate) navigator.vibrate(30);
    }

    // Speak function
    function speak(text) {
      send({ type: 'speak', text: text });
      if (navigator.vibrate) navigator.vibrate(30);
    }

    // Trigger action (for sounds, etc.)
    function triggerAction(action) {
      send({ type: 'action', action: { name: action } });
      if (navigator.vibrate) navigator.vibrate(30);
    }

    // Fullscreen
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
          console.log('Fullscreen not available');
        });
      } else {
        document.exitFullscreen();
      }
    }

    // Prevent default touch behaviors
    document.addEventListener('touchmove', (e) => {
      if (e.target.closest('#controller')) {
        e.preventDefault();
      }
    }, { passive: false });

    // Initialize
    window.addEventListener('load', () => {
      connect();
      loadExtensionButtons();

      // Recalculate joystick center on resize/orientation change
      window.addEventListener('resize', () => {
        setTimeout(() => {
          const rect = joystickContainer.getBoundingClientRect();
          joystickCenter = {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2
          };
        }, 100);
      });

      // Keep screen on - additional check every 30 seconds
      setInterval(async () => {
        if (!wakeLock && document.visibilityState === 'visible') {
          try {
            if ('wakeLock' in navigator) {
              wakeLock = await navigator.wakeLock.request('screen');
              console.log('Wake lock re-acquired via interval');
            }
          } catch (err) {
            console.log('Wake lock failed:', err);
          }
        }
      }, 30000);

      // Prevent the screen from sleeping by keeping activity going
      setInterval(() => {
        // Touch the connection to keep things active
        if (ws && ws.readyState === WebSocket.OPEN) {
          send({ type: 'ping' });
        }
      }, 60000);
    });
  </script>
</body>
</html>
