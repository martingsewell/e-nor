<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>E-NOR</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      height: 100dvh; /* dynamic viewport height - accounts for browser bars */
      overflow: hidden;
      display: flex;
      flex-direction: column;
      font-family: Arial, sans-serif;
      background: #1a1a2e;
      transition: background-color 0.1s;
    }

    /* Top section: Face */
    #face-container {
      flex: 0 0 45%;
      min-height: 180px;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    #face-svg { transition: transform 0.1s; }
    #face-svg.disco-bounce {
      animation: discoBounce 0.5s ease-in-out infinite;
    }
    @keyframes discoBounce {
      0%, 100% { transform: translateY(0) rotate(0deg) scale(1); }
      25% { transform: translateY(-10px) rotate(-3deg) scale(1.03); }
      50% { transform: translateY(0) rotate(0deg) scale(1); }
      75% { transform: translateY(-10px) rotate(3deg) scale(1.03); }
    }
    #name {
      font-size: 20px;
      font-weight: bold;
      letter-spacing: 6px;
      color: #00ffff;
      text-shadow: 0 0 15px #00ffff;
      margin-top: 5px;
    }
    #name.disco-shake {
      animation: discoShake 0.3s ease-in-out infinite;
    }
    @keyframes discoShake {
      0%, 100% { transform: translateX(0) scale(1); }
      25% { transform: translateX(-5px) scale(1.05); }
      75% { transform: translateX(5px) scale(1.05); }
    }

    /* Status and Settings */
    #status {
      position: absolute;
      top: 10px;
      right: 45px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ff4444;
    }
    #status.connected { background: #00ff00; }

    #settings-btn {
      position: absolute;
      top: 8px;
      right: 10px;
      font-size: 24px;
      background: none;
      border: none;
      cursor: pointer;
      opacity: 0.7;
      padding: 0;
    }
    #settings-btn:hover { opacity: 1; }

    /* Bottom section: Chat */
    #chat-container {
      flex: 1;
      min-height: 0; /* important for flex scroll */
      display: flex;
      flex-direction: column;
      background: #0d0d1a;
      border-top: 2px solid #333;
    }

    #chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .message {
      max-width: 85%;
      padding: 10px 14px;
      border-radius: 18px;
      font-size: 14px;
      line-height: 1.4;
      word-wrap: break-word;
    }
    .message.user {
      align-self: flex-end;
      background: #0066cc;
      color: white;
      border-bottom-right-radius: 4px;
    }
    .message.enor {
      align-self: flex-start;
      background: #333;
      color: #00ffff;
      border-bottom-left-radius: 4px;
    }
    .message.enor.thinking {
      background: #222;
      color: #888;
      font-style: italic;
    }
    .message.system {
      align-self: center;
      background: #442222;
      color: #ffaa88;
      font-size: 12px;
      max-width: 95%;
    }
    .message.system code {
      background: #333;
      padding: 2px 6px;
      border-radius: 4px;
      font-family: monospace;
      color: #00ffff;
    }
    .message.system strong {
      color: #ffcc88;
    }

    #chat-input-container {
      display: flex;
      gap: 8px;
      padding: 10px;
      background: #1a1a2e;
      border-top: 1px solid #333;
    }

    #chat-input {
      flex: 1;
      padding: 12px 16px;
      font-size: 16px;
      border: 2px solid #333;
      border-radius: 25px;
      background: #0d0d1a;
      color: white;
      outline: none;
    }
    #chat-input:focus {
      border-color: #00ffff;
    }
    #chat-input::placeholder {
      color: #666;
    }

    #send-btn {
      padding: 12px 20px;
      font-size: 16px;
      background: #00ffff;
      color: #000;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      font-weight: bold;
    }
    #send-btn:disabled {
      background: #333;
      color: #666;
      cursor: not-allowed;
    }

    /* Quick actions */
    #quick-actions {
      display: flex;
      gap: 6px;
      padding: 6px 10px;
      overflow-x: auto;
      background: #0d0d1a;
    }
    .quick-btn {
      padding: 6px 12px;
      font-size: 11px;
      background: #222;
      color: #aaa;
      border: 1px solid #444;
      border-radius: 15px;
      cursor: pointer;
      white-space: nowrap;
    }
    .quick-btn:hover {
      background: #333;
      color: #fff;
    }
    #disco-btn.active { background: #ff00ff; color: #000; border-color: #ff00ff; }

    /* Voice indicator */
    #voice-status {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 15px;
      font-size: 11px;
      background: #222;
      color: #888;
    }
    #voice-status.listening {
      background: #002200;
      color: #00ff00;
    }
    #voice-status.conversation {
      background: #220022;
      color: #ff00ff;
      animation: pulse 1s infinite;
    }
    #voice-status.speaking {
      background: #002222;
      color: #00ffff;
    }
    #voice-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #666;
    }
    #voice-status.listening #voice-dot { background: #00ff00; }
    #voice-status.conversation #voice-dot { background: #ff00ff; }
    #voice-status.speaking #voice-dot { background: #00ffff; }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    /* Mic button */
    #mic-btn {
      padding: 12px;
      font-size: 20px;
      background: #333;
      color: #fff;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #mic-btn.active {
      background: #ff00ff;
      animation: pulse 1s infinite;
    }
    #mic-btn.speaking {
      background: #ff4444;
      animation: none;
    }
    #mic-btn:disabled {
      background: #222;
      color: #555;
      cursor: not-allowed;
    }

    /* Interrupt Button - shows during speech */
    #interrupt-btn {
      display: none;
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      padding: 15px 30px;
      font-size: 16px;
      font-weight: bold;
      background: #ff4444;
      color: white;
      border: none;
      border-radius: 30px;
      cursor: pointer;
      z-index: 100;
      box-shadow: 0 4px 15px rgba(255,68,68,0.5);
      animation: pulseInterrupt 1s infinite;
    }
    #interrupt-btn.visible {
      display: block;
    }
    @keyframes pulseInterrupt {
      0%, 100% { transform: translateX(-50%) scale(1); }
      50% { transform: translateX(-50%) scale(1.05); }
    }

    /* Settings Modal */
    #settings-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      z-index: 1000;
      flex-direction: column;
      padding: 20px;
      overflow-y: auto;
    }
    #settings-modal.visible { display: flex; }

    #settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    #settings-header h2 {
      color: #00ffff;
      font-size: 20px;
    }
    #close-settings {
      font-size: 28px;
      background: none;
      border: none;
      color: #fff;
      cursor: pointer;
    }

    .secret-item {
      background: #1a1a2e;
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 15px;
    }
    .secret-item h3 {
      color: #fff;
      font-size: 14px;
      margin-bottom: 5px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .secret-item .hint {
      color: #888;
      font-size: 12px;
      margin-bottom: 10px;
    }
    .secret-item .status-icon {
      font-size: 16px;
    }
    .secret-item .status-icon.configured { color: #00ff00; }
    .secret-item .status-icon.missing { color: #ff4444; }

    .secret-form {
      display: flex;
      gap: 8px;
    }
    .secret-form input {
      flex: 1;
      padding: 10px;
      border: 1px solid #333;
      border-radius: 8px;
      background: #0d0d1a;
      color: #fff;
      font-size: 14px;
    }
    .secret-form input::placeholder { color: #666; }
    .secret-form button {
      padding: 10px 15px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
    }
    .secret-form .save-btn {
      background: #00ff00;
      color: #000;
    }
    .secret-form .delete-btn {
      background: #ff4444;
      color: #fff;
    }

    #test-connection {
      width: 100%;
      padding: 15px;
      background: #333;
      color: #fff;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      cursor: pointer;
      margin-top: 10px;
    }
    #test-connection:hover { background: #444; }

    #connection-result {
      text-align: center;
      padding: 10px;
      margin-top: 10px;
      border-radius: 8px;
      font-size: 14px;
    }
    #connection-result.success { background: #224422; color: #00ff00; }
    #connection-result.error { background: #442222; color: #ff4444; }

    /* Dev Mode Toggle */
    .dev-mode-toggle {
      background: #1a1a2e;
      border-radius: 10px;
      padding: 15px;
      margin-top: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .dev-mode-toggle h3 {
      color: #fff;
      font-size: 14px;
      margin: 0;
    }
    .dev-mode-toggle p {
      color: #888;
      font-size: 12px;
      margin: 5px 0 0 0;
    }
    .toggle-switch {
      position: relative;
      width: 50px;
      height: 26px;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #333;
      border-radius: 26px;
      transition: 0.3s;
    }
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 3px;
      bottom: 3px;
      background: #fff;
      border-radius: 50%;
      transition: 0.3s;
    }
    .toggle-switch input:checked + .toggle-slider {
      background: #00ff00;
    }
    .toggle-switch input:checked + .toggle-slider:before {
      transform: translateX(24px);
    }

    /* Dev Console Panel */
    #dev-console {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 35%;
      background: rgba(0, 0, 0, 0.95);
      border-top: 2px solid #00ff00;
      z-index: 999;
      flex-direction: column;
    }
    #dev-console.visible {
      display: flex;
    }
    #dev-console-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: #111;
      border-bottom: 1px solid #333;
    }
    #dev-console-header h4 {
      color: #00ff00;
      font-size: 12px;
      margin: 0;
      font-family: monospace;
    }
    #dev-console-header button {
      background: #333;
      border: none;
      color: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
      margin-left: 8px;
    }
    #dev-console-header button:hover {
      background: #444;
    }
    #console-output {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
      font-family: monospace;
      font-size: 11px;
    }
    .console-line {
      padding: 3px 0;
      border-bottom: 1px solid #222;
      word-break: break-all;
    }
    .console-line.log { color: #aaa; }
    .console-line.info { color: #00ffff; }
    .console-line.warn { color: #ffaa00; }
    .console-line.error { color: #ff4444; }
    .console-line.speech { color: #ff00ff; }
    .console-line .timestamp {
      color: #666;
      margin-right: 8px;
    }
    #speech-preview {
      padding: 8px 12px;
      background: #1a001a;
      border-top: 1px solid #333;
      font-family: monospace;
      font-size: 12px;
      color: #ff00ff;
    }
    #speech-preview strong {
      color: #ff88ff;
    }
  </style>
</head>
<body>
  <!-- Top: Face -->
  <div id="face-container">
    <div id="voice-status">
      <div id="voice-dot"></div>
      <span id="voice-text">Say "Hey E-NOR"</span>
    </div>
    <div id="status"></div>
    <button id="settings-btn" onclick="openSettings()">&#9881;</button>

    <svg id="face-svg" width="200" height="200" viewBox="0 0 400 400">
      <circle id="ring" cx="200" cy="200" r="180" fill="none" stroke="#00ffff" stroke-width="8" opacity="0.4"/>
      <g id="leds"></g>
      <line id="left-brow" x1="110" y1="105" x2="170" y2="105" stroke="#00ffff" stroke-width="6" stroke-linecap="round"/>
      <line id="right-brow" x1="230" y1="105" x2="290" y2="105" stroke="#00ffff" stroke-width="6" stroke-linecap="round"/>
      <ellipse id="left-eye" cx="140" cy="140" rx="35" ry="30" fill="#00ffff"/>
      <ellipse id="left-pupil" cx="145" cy="145" rx="12" ry="12" fill="#000"/>
      <ellipse id="right-eye" cx="260" cy="140" rx="35" ry="30" fill="#00ffff"/>
      <ellipse id="right-pupil" cx="265" cy="145" rx="12" ry="12" fill="#000"/>
      <path id="mouth" d="M 120 220 Q 200 280 280 220" stroke="#00ffff" stroke-width="6" stroke-linecap="round" fill="none"/>
    </svg>

    <div id="name">E-NOR</div>
  </div>

  <!-- Bottom: Chat -->
  <div id="chat-container">
    <div id="quick-actions">
      <button class="quick-btn" onclick="setEmotion('happy')">Happy</button>
      <button class="quick-btn" onclick="setEmotion('sad')">Sad</button>
      <button class="quick-btn" onclick="setEmotion('surprised')">Surprised</button>
      <button class="quick-btn" onclick="setEmotion('thinking')">Thinking</button>
      <button class="quick-btn" onclick="toggleDisco()" id="disco-btn">DISCO</button>
    </div>

    <div id="chat-messages">
      <!-- Messages will appear here -->
    </div>

    <button id="interrupt-btn" onclick="interruptSpeech()">TAP TO INTERRUPT</button>

    <div id="chat-input-container">
      <button id="mic-btn" onclick="toggleVoiceMode()">&#127908;</button>
      <input type="text" id="chat-input" placeholder="Say something to E-NOR..." autocomplete="off">
      <button id="send-btn" onclick="sendMessage()">Send</button>
    </div>
  </div>

  <!-- Settings Modal -->
  <div id="settings-modal">
    <div id="settings-header">
      <h2>E-NOR Settings</h2>
      <button id="close-settings" onclick="closeSettings()">&times;</button>
    </div>

    <div id="secrets-list">
      <!-- Secrets will be loaded here -->
    </div>

    <button id="test-connection" onclick="testConnection()">Test Chat Connection</button>
    <div id="connection-result"></div>

    <div class="dev-mode-toggle">
      <div>
        <h3>Developer Mode</h3>
        <p>Show on-screen console & speech debug</p>
      </div>
      <label class="toggle-switch">
        <input type="checkbox" id="dev-mode-checkbox" onchange="toggleDevMode()">
        <span class="toggle-slider"></span>
      </label>
    </div>
  </div>

  <!-- Dev Console -->
  <div id="dev-console">
    <div id="dev-console-header">
      <h4>E-NOR Dev Console</h4>
      <div>
        <button onclick="copyDevConsole()" id="copy-btn">Copy</button>
        <button onclick="clearDevConsole()">Clear</button>
        <button onclick="toggleDevMode()">Close</button>
      </div>
    </div>
    <div id="console-output">
      <!-- Console logs appear here -->
    </div>
    <div id="speech-preview">
      <strong>Speech:</strong> <span id="speech-text">Waiting for speech...</span>
    </div>
  </div>

  <script>
    // ==================== Dev Console ====================
    let devModeEnabled = localStorage.getItem('devMode') === 'true';
    const devConsole = document.getElementById('dev-console');
    const consoleOutput = document.getElementById('console-output');
    const speechTextEl = document.getElementById('speech-text');
    const devModeCheckbox = document.getElementById('dev-mode-checkbox');

    // Restore dev mode state
    if (devModeEnabled) {
      devConsole.classList.add('visible');
      devModeCheckbox.checked = true;
    }

    // Intercept console methods
    const originalConsole = {
      log: console.log.bind(console),
      warn: console.warn.bind(console),
      error: console.error.bind(console),
      info: console.info.bind(console)
    };

    function addToDevConsole(type, args) {
      if (!devModeEnabled) return;

      const line = document.createElement('div');
      line.className = `console-line ${type}`;

      const time = new Date().toLocaleTimeString('en-GB', {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 1
      });

      const message = Array.from(args).map(arg => {
        if (typeof arg === 'object') {
          try {
            return JSON.stringify(arg);
          } catch (e) {
            return String(arg);
          }
        }
        return String(arg);
      }).join(' ');

      line.innerHTML = `<span class="timestamp">${time}</span>${message}`;
      consoleOutput.appendChild(line);

      // Keep only last 100 lines
      while (consoleOutput.children.length > 100) {
        consoleOutput.removeChild(consoleOutput.firstChild);
      }

      // Auto-scroll to bottom
      consoleOutput.scrollTop = consoleOutput.scrollHeight;
    }

    console.log = function(...args) {
      originalConsole.log(...args);
      addToDevConsole('log', args);
    };

    console.warn = function(...args) {
      originalConsole.warn(...args);
      addToDevConsole('warn', args);
    };

    console.error = function(...args) {
      originalConsole.error(...args);
      addToDevConsole('error', args);
    };

    console.info = function(...args) {
      originalConsole.info(...args);
      addToDevConsole('info', args);
    };

    function logSpeech(text, isFinal) {
      if (devModeEnabled && speechTextEl) {
        speechTextEl.textContent = isFinal ? `"${text}" âœ“` : `"${text}"...`;
      }
    }

    function toggleDevMode() {
      devModeEnabled = !devModeEnabled;
      localStorage.setItem('devMode', devModeEnabled);
      devConsole.classList.toggle('visible', devModeEnabled);
      devModeCheckbox.checked = devModeEnabled;

      if (devModeEnabled) {
        console.log('Dev mode enabled');
      }
    }

    function clearDevConsole() {
      consoleOutput.innerHTML = '';
      speechTextEl.textContent = 'Waiting for speech...';
      console.log('Console cleared');
    }

    function copyDevConsole() {
      const lines = Array.from(consoleOutput.querySelectorAll('.console-line')).map(line => {
        const timestamp = line.querySelector('.timestamp')?.textContent || '';
        const text = line.textContent.replace(timestamp, '').trim();
        return timestamp + text;
      });
      const speechText = speechTextEl?.textContent || '';
      const fullText = lines.join('\n') + '\n\n[Speech: ' + speechText + ']';

      navigator.clipboard.writeText(fullText).then(() => {
        const copyBtn = document.getElementById('copy-btn');
        copyBtn.textContent = 'Copied!';
        copyBtn.style.background = '#00ff00';
        copyBtn.style.color = '#000';
        setTimeout(() => {
          copyBtn.textContent = 'Copy';
          copyBtn.style.background = '';
          copyBtn.style.color = '';
        }, 1500);
      }).catch(() => {
        alert('Copy failed - try selecting text manually');
      });
    }

    // ==================== WebSocket ====================
    let ws = null;
    const statusEl = document.getElementById('status');

    function connect() {
      const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${protocol}//${location.host}/ws`);

      ws.onopen = () => {
        console.log('Connected to E-NOR');
        statusEl.classList.add('connected');
      };

      ws.onclose = () => {
        console.log('Disconnected, reconnecting...');
        statusEl.classList.remove('connected');
        setTimeout(connect, 2000);
      };

      ws.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        if (msg.type === 'emotion') {
          applyEmotion(msg.emotion);
        } else if (msg.type === 'disco') {
          if (msg.enabled && !discoMode) toggleDisco();
          else if (!msg.enabled && discoMode) toggleDisco();
        } else if (msg.type === 'state') {
          applyEmotion(msg.data.emotion);
          if (msg.data.disco_mode) toggleDisco();
        }
      };
    }

    function send(data) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(data));
      }
    }

    // ==================== Emotions ====================
    const emotions = {
      happy: { eyeH: 30, eyeY: 140, pupilY: 145, mouth: "M 120 220 Q 200 280 280 220", browAngle: 0, color: "#00ffff" },
      sad: { eyeH: 20, eyeY: 150, pupilY: 155, mouth: "M 130 250 Q 200 210 270 250", browAngle: 15, color: "#6688ff" },
      angry: { eyeH: 20, eyeY: 145, pupilY: 150, mouth: "M 140 250 L 200 240 L 260 250", browAngle: -20, color: "#ff4444" },
      surprised: { eyeH: 45, eyeY: 135, pupilY: 150, mouth: "M 170 230 A 30 30 0 1 1 230 230 A 30 30 0 1 1 170 230", browAngle: 0, color: "#ffff00" },
      thinking: { eyeH: 25, eyeY: 145, pupilY: 150, mouth: "M 150 240 Q 200 240 220 235", browAngle: 10, color: "#aa88ff" },
      sleepy: { eyeH: 8, eyeY: 155, pupilY: 155, mouth: "M 160 240 Q 200 250 240 240", browAngle: 5, color: "#88aacc" }
    };

    let currentEmotion = 'happy';
    let discoMode = false;
    let discoHue = 0;
    let audioCtx = null;
    let discoInterval = null;
    let expressionInterval = null;
    const discoEmotions = ['happy', 'surprised', 'happy', 'thinking'];
    let discoEmotionIndex = 0;

    // Create LED circles
    const ledsGroup = document.getElementById('leds');
    for (let i = 0; i < 12; i++) {
      const angle = (i * 30 - 90) * Math.PI / 180;
      const x = 200 + 180 * Math.cos(angle);
      const y = 200 + 180 * Math.sin(angle);
      const led = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      led.setAttribute("cx", x);
      led.setAttribute("cy", y);
      led.setAttribute("r", 8);
      led.setAttribute("fill", "#00ffff");
      led.id = `led-${i}`;
      ledsGroup.appendChild(led);
    }

    function setEmotion(name) {
      if (discoMode) toggleDisco();
      currentEmotion = name;
      applyEmotion(name);
      send({ type: 'emotion', emotion: name });
    }

    function applyEmotion(name) {
      currentEmotion = name;
      const e = emotions[name];
      if (!e) return;

      document.getElementById('left-eye').setAttribute('cy', e.eyeY);
      document.getElementById('left-eye').setAttribute('ry', e.eyeH);
      document.getElementById('right-eye').setAttribute('cy', e.eyeY);
      document.getElementById('right-eye').setAttribute('ry', e.eyeH);
      document.getElementById('left-pupil').setAttribute('cy', e.pupilY);
      document.getElementById('left-pupil').setAttribute('ry', Math.min(12, e.eyeH - 5));
      document.getElementById('right-pupil').setAttribute('cy', e.pupilY);
      document.getElementById('right-pupil').setAttribute('ry', Math.min(12, e.eyeH - 5));
      document.getElementById('mouth').setAttribute('d', e.mouth);

      document.getElementById('left-brow').setAttribute('y1', 105 + e.browAngle);
      document.getElementById('left-brow').setAttribute('y2', 105 - e.browAngle);
      document.getElementById('right-brow').setAttribute('y1', 105 - e.browAngle);
      document.getElementById('right-brow').setAttribute('y2', 105 + e.browAngle);

      setColor(e.color);
    }

    function setColor(color) {
      document.getElementById('ring').setAttribute('stroke', color);
      document.getElementById('left-eye').setAttribute('fill', color);
      document.getElementById('right-eye').setAttribute('fill', color);
      document.getElementById('left-brow').setAttribute('stroke', color);
      document.getElementById('right-brow').setAttribute('stroke', color);
      document.getElementById('mouth').setAttribute('stroke', color);
      document.getElementById('name').style.color = color;
      document.getElementById('name').style.textShadow = `0 0 15px ${color}`;
      for (let i = 0; i < 12; i++) {
        document.getElementById(`led-${i}`).setAttribute('fill', color);
      }
    }

    // ==================== Disco Mode ====================
    function createDiscoMusic() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
      return audioCtx;
    }

    function playDiscoBeat() {
      if (!audioCtx || !discoMode) return;

      const now = audioCtx.currentTime;

      // Kick drum
      const kickOsc = audioCtx.createOscillator();
      const kickGain = audioCtx.createGain();
      kickOsc.type = 'sine';
      kickOsc.frequency.setValueAtTime(150, now);
      kickOsc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
      kickGain.gain.setValueAtTime(0.8, now);
      kickGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
      kickOsc.connect(kickGain);
      kickGain.connect(audioCtx.destination);
      kickOsc.start(now);
      kickOsc.stop(now + 0.2);

      // Hi-hat on off-beats
      setTimeout(() => {
        if (!discoMode) return;
        const hihatOsc = audioCtx.createOscillator();
        const hihatGain = audioCtx.createGain();
        const hihatFilter = audioCtx.createBiquadFilter();
        hihatOsc.type = 'square';
        hihatOsc.frequency.setValueAtTime(800, audioCtx.currentTime);
        hihatFilter.type = 'highpass';
        hihatFilter.frequency.setValueAtTime(7000, audioCtx.currentTime);
        hihatGain.gain.setValueAtTime(0.15, audioCtx.currentTime);
        hihatGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
        hihatOsc.connect(hihatFilter);
        hihatFilter.connect(hihatGain);
        hihatGain.connect(audioCtx.destination);
        hihatOsc.start(audioCtx.currentTime);
        hihatOsc.stop(audioCtx.currentTime + 0.05);
      }, 125);

      // Funky bass note
      const bassNotes = [110, 130.81, 146.83, 164.81];
      const bassNote = bassNotes[Math.floor(Math.random() * bassNotes.length)];
      const bassOsc = audioCtx.createOscillator();
      const bassGain = audioCtx.createGain();
      bassOsc.type = 'sawtooth';
      bassOsc.frequency.setValueAtTime(bassNote, now);
      bassGain.gain.setValueAtTime(0.3, now);
      bassGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
      bassOsc.connect(bassGain);
      bassGain.connect(audioCtx.destination);
      bassOsc.start(now + 0.05);
      bassOsc.stop(now + 0.2);
    }

    function startDiscoMusic() {
      createDiscoMusic();
      playDiscoBeat();
      discoInterval = setInterval(playDiscoBeat, 250);
    }

    function stopDiscoMusic() {
      if (discoInterval) {
        clearInterval(discoInterval);
        discoInterval = null;
      }
    }

    function toggleDisco() {
      discoMode = !discoMode;
      document.getElementById('disco-btn').classList.toggle('active');

      const faceSvg = document.getElementById('face-svg');
      const nameEl = document.getElementById('name');

      if (discoMode) {
        faceSvg.classList.add('disco-bounce');
        nameEl.classList.add('disco-shake');
        startDiscoMusic();

        discoEmotionIndex = 0;
        expressionInterval = setInterval(() => {
          discoEmotionIndex = (discoEmotionIndex + 1) % discoEmotions.length;
          const emotion = discoEmotions[discoEmotionIndex];
          const e = emotions[emotion];

          document.getElementById('left-eye').setAttribute('cy', e.eyeY);
          document.getElementById('left-eye').setAttribute('ry', e.eyeH);
          document.getElementById('right-eye').setAttribute('cy', e.eyeY);
          document.getElementById('right-eye').setAttribute('ry', e.eyeH);
          document.getElementById('left-pupil').setAttribute('cy', e.pupilY);
          document.getElementById('left-pupil').setAttribute('ry', Math.min(12, e.eyeH - 5));
          document.getElementById('right-pupil').setAttribute('cy', e.pupilY);
          document.getElementById('right-pupil').setAttribute('ry', Math.min(12, e.eyeH - 5));
          document.getElementById('mouth').setAttribute('d', e.mouth);
          document.getElementById('left-brow').setAttribute('y1', 105 + e.browAngle);
          document.getElementById('left-brow').setAttribute('y2', 105 - e.browAngle);
          document.getElementById('right-brow').setAttribute('y1', 105 - e.browAngle);
          document.getElementById('right-brow').setAttribute('y2', 105 + e.browAngle);
        }, 500);
      } else {
        faceSvg.classList.remove('disco-bounce');
        nameEl.classList.remove('disco-shake');
        stopDiscoMusic();

        if (expressionInterval) {
          clearInterval(expressionInterval);
          expressionInterval = null;
        }
        applyEmotion('happy');
      }

      send({ type: 'disco', enabled: discoMode });
    }

    // Disco animation loop
    setInterval(() => {
      if (discoMode) {
        discoHue = (discoHue + 3) % 360;
        document.body.style.background = `hsl(${discoHue}, 80%, 15%)`;
        document.getElementById('ring').setAttribute('stroke-width', 15);
        document.getElementById('ring').setAttribute('opacity', 0.9);

        for (let i = 0; i < 12; i++) {
          const ledHue = (discoHue + i * 30) % 360;
          document.getElementById(`led-${i}`).setAttribute('fill', `hsl(${ledHue}, 100%, 60%)`);
          document.getElementById(`led-${i}`).setAttribute('r', 12);
        }

        const mainColor = `hsl(${discoHue}, 100%, 60%)`;
        document.getElementById('left-eye').setAttribute('fill', mainColor);
        document.getElementById('right-eye').setAttribute('fill', mainColor);
        document.getElementById('left-brow').setAttribute('stroke', mainColor);
        document.getElementById('right-brow').setAttribute('stroke', mainColor);
        document.getElementById('mouth').setAttribute('stroke', mainColor);
        document.getElementById('name').style.color = mainColor;
        document.getElementById('name').style.textShadow = `0 0 15px ${mainColor}`;
      } else {
        document.body.style.background = '#1a1a2e';
        document.getElementById('ring').setAttribute('stroke-width', 8);
        document.getElementById('ring').setAttribute('opacity', 0.4);
        for (let i = 0; i < 12; i++) {
          document.getElementById(`led-${i}`).setAttribute('r', 8);
        }
      }
    }, 50);

    // Blinking
    setInterval(() => {
      if (discoMode) return;
      const e = emotions[currentEmotion];
      document.getElementById('left-eye').setAttribute('ry', 3);
      document.getElementById('right-eye').setAttribute('ry', 3);
      document.getElementById('left-pupil').style.display = 'none';
      document.getElementById('right-pupil').style.display = 'none';

      setTimeout(() => {
        document.getElementById('left-eye').setAttribute('ry', e.eyeH);
        document.getElementById('right-eye').setAttribute('ry', e.eyeH);
        document.getElementById('left-pupil').style.display = 'block';
        document.getElementById('right-pupil').style.display = 'block';
      }, 150);
    }, 3000 + Math.random() * 2000);

    // ==================== Chat ====================
    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const sendBtn = document.getElementById('send-btn');
    let conversationId = 'ronnie-' + Date.now();
    let isWaitingForResponse = false;

    function addMessage(text, type) {
      const msg = document.createElement('div');
      msg.className = `message ${type}`;
      msg.textContent = text;
      chatMessages.appendChild(msg);
      chatMessages.scrollTop = chatMessages.scrollHeight;
      return msg;
    }

    async function sendMessage() {
      const text = chatInput.value.trim();
      if (!text || isWaitingForResponse) return;

      // Add user message
      addMessage(text, 'user');
      chatInput.value = '';

      // Show thinking state
      isWaitingForResponse = true;
      sendBtn.disabled = true;
      applyEmotion('thinking');
      const thinkingMsg = addMessage('Thinking...', 'enor thinking');

      try {
        const response = await fetch('/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message: text,
            conversation_id: conversationId
          })
        });

        const data = await response.json();

        // Remove thinking message
        thinkingMsg.remove();

        // Add E-NOR's response
        addMessage(data.response, 'enor');

        // Update emotion based on response
        if (data.emotion && emotions[data.emotion]) {
          applyEmotion(data.emotion);
          send({ type: 'emotion', emotion: data.emotion });
        }
      } catch (error) {
        thinkingMsg.remove();
        addMessage('Oops! Something went wrong. Try again?', 'system');
        applyEmotion('sad');
      }

      isWaitingForResponse = false;
      sendBtn.disabled = false;
      chatInput.focus();
    }

    // Enter key to send
    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    // ==================== Settings ====================
    function openSettings() {
      document.getElementById('settings-modal').classList.add('visible');
      loadSecrets();
    }

    function closeSettings() {
      document.getElementById('settings-modal').classList.remove('visible');
    }

    async function loadSecrets() {
      const secretsList = document.getElementById('secrets-list');

      try {
        const response = await fetch('/api/secrets');
        const data = await response.json();

        secretsList.innerHTML = data.templates.map(template => `
          <div class="secret-item" data-name="${template.name}">
            <h3>
              <span class="status-icon ${template.configured ? 'configured' : 'missing'}">
                ${template.configured ? '&#10004;' : '&#10008;'}
              </span>
              ${template.label}
              ${template.required ? '<span style="color: #ff6666; font-size: 11px;">(required)</span>' : ''}
            </h3>
            <p class="hint">${template.hint}</p>
            <div class="secret-form">
              <input type="password" placeholder="${template.configured ? '******* (saved)' : 'Enter value...'}" id="input-${template.name}">
              <button class="save-btn" onclick="saveSecret('${template.name}')">Save</button>
              ${template.configured ? `<button class="delete-btn" onclick="deleteSecret('${template.name}')">Delete</button>` : ''}
            </div>
          </div>
        `).join('');
      } catch (error) {
        secretsList.innerHTML = '<p style="color: #ff6666;">Could not load settings. Is E-NOR connected?</p>';
      }
    }

    async function saveSecret(name) {
      const input = document.getElementById(`input-${name}`);
      const value = input.value.trim();

      if (!value) {
        alert('Please enter a value');
        return;
      }

      try {
        const response = await fetch('/api/secrets', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, value })
        });

        if (response.ok) {
          input.value = '';
          loadSecrets();
        } else {
          alert('Failed to save secret');
        }
      } catch (error) {
        alert('Could not save secret. Is E-NOR connected?');
      }
    }

    async function deleteSecret(name) {
      if (!confirm(`Delete ${name}?`)) return;

      try {
        const response = await fetch(`/api/secrets/${name}`, {
          method: 'DELETE'
        });

        if (response.ok) {
          loadSecrets();
        } else {
          alert('Failed to delete secret');
        }
      } catch (error) {
        alert('Could not delete secret');
      }
    }

    async function testConnection() {
      const resultEl = document.getElementById('connection-result');
      resultEl.textContent = 'Testing...';
      resultEl.className = '';

      try {
        const response = await fetch('/api/chat/status');
        const data = await response.json();

        if (data.ready) {
          resultEl.textContent = 'Chat is ready! Claude API key is configured.';
          resultEl.className = 'success';
        } else {
          resultEl.textContent = 'Chat not ready: ' + data.message;
          resultEl.className = 'error';
        }
      } catch (error) {
        resultEl.textContent = 'Could not connect to E-NOR server';
        resultEl.className = 'error';
      }
    }

    // ==================== Voice Interface ====================
    const voiceStatus = document.getElementById('voice-status');
    const voiceText = document.getElementById('voice-text');
    const micBtn = document.getElementById('mic-btn');

    let recognition = null;
    let synthesis = window.speechSynthesis;
    let voiceMode = 'idle'; // 'idle', 'listening', 'conversation', 'speaking'
    let inConversation = false;
    let voiceSupported = false;
    let micPermissionGranted = false;
    let isSpeaking = false;
    let speechBuffer = '';
    let speechTimeout = null;
    let pendingAbortController = null; // For canceling requests if user keeps talking
    let isProcessing = false; // True during API call
    const SILENCE_DELAY = 3000; // Wait 3 seconds of silence before processing

    // Check if speech recognition is supported
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (SpeechRecognition) {
      voiceSupported = true;
      recognition = new SpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = true; // Get interim results for better responsiveness
      recognition.lang = 'en-GB';

      recognition.onresult = handleSpeechResult;
      recognition.onerror = handleSpeechError;
      recognition.onend = handleSpeechEnd;
      recognition.onstart = () => {
        console.log('Speech recognition started');
        micPermissionGranted = true;
      };
    } else {
      voiceText.textContent = 'Voice not supported';
      micBtn.disabled = true;
    }

    function setVoiceState(state, text) {
      voiceMode = state;
      voiceStatus.className = state === 'idle' ? '' : state;
      voiceText.textContent = text;
      micBtn.classList.remove('active', 'speaking');
      if (state === 'speaking') {
        micBtn.classList.add('speaking');
      } else if (inConversation) {
        micBtn.classList.add('active');
      }
    }

    async function requestMicPermission() {
      try {
        // Request microphone permission explicitly
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        // Stop the stream immediately - we just needed permission
        stream.getTracks().forEach(track => track.stop());
        micPermissionGranted = true;
        console.log('Microphone permission granted');
        return true;
      } catch (e) {
        console.error('Microphone permission denied:', e);
        setVoiceState('idle', 'Mic denied - tap for help');
        // Show help message in chat
        showMicHelp();
        return false;
      }
    }

    function showMicHelp() {
      // Check if we already showed help
      if (document.querySelector('.mic-help-message')) return;

      const helpMsg = document.createElement('div');
      helpMsg.className = 'message system mic-help-message';
      helpMsg.innerHTML = `
        <strong>Microphone blocked!</strong> This is because the site uses HTTP, not HTTPS.<br><br>
        <strong>To fix on Chrome Android:</strong><br>
        1. Open: <code>chrome://flags</code><br>
        2. Search: "insecure origins"<br>
        3. Find: "Insecure origins treated as secure"<br>
        4. Add: <code>http://192.168.0.40:8080</code><br>
        5. Tap Enable, then Relaunch<br><br>
        <em>Or just use the text chat below!</em>
      `;
      chatMessages.appendChild(helpMsg);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    async function startListening() {
      if (!voiceSupported || !recognition) return;

      // NEVER start listening while E-NOR is speaking
      if (isSpeaking) {
        console.log('Blocked startListening - E-NOR is speaking');
        return;
      }

      // First request mic permission if not granted
      if (!micPermissionGranted) {
        const granted = await requestMicPermission();
        if (!granted) return;
      }

      try {
        recognition.start();
        setVoiceState(inConversation ? 'conversation' : 'listening', inConversation ? 'Listening...' : 'Say "Hey E-NOR"');
      } catch (e) {
        if (e.name === 'InvalidStateError') {
          // Already started, that's fine
        } else {
          console.error('Recognition start error:', e);
          setVoiceState('idle', 'Tap mic to start');
        }
      }
    }

    function stopListening() {
      if (!recognition) return;
      try {
        recognition.abort(); // Use abort() instead of stop() for immediate halt
      } catch (e) {}
    }

    function handleSpeechResult(event) {
      // Ignore speech while E-NOR is speaking (prevents echo)
      if (isSpeaking) {
        console.log('Ignoring speech - E-NOR is speaking');
        return;
      }

      const last = event.results.length - 1;
      const result = event.results[last];
      const transcript = result[0].transcript.toLowerCase().trim();

      // Log to dev console
      logSpeech(transcript, result.isFinal);

      if (!inConversation) {
        // For wake word, check on final results only
        if (result.isFinal) {
          console.log('Heard (wake check):', transcript);
          // Many phonetic variations of "Hey E-NOR"
          const wakeWords = [
            'hey e-nor', 'hey enor', 'hey e nor', 'heyeanor',
            'a nor', 'enor', 'hey nor', 'e-nor', 'eanor',
            'iy nore', 'e nore', 'ee nor', 'eenor', 'i nor',
            'inor', 'ey nor', 'ay nor', 'ae nor', 'hey noor',
            'he nor', 'henor', 'hi nor', 'hinor', 'hey nora',
            'hey ignore', 'hey in or', 'hey anna', 'inna',
            'hey naw', 'eena', 'ena', 'eenore', 'eynor',
            'hey eno', 'heyeno', 'eno', 'hey in', 'a no'
          ];
          if (wakeWords.some(w => transcript.includes(w))) {
            startConversation();
          }
        }
      } else {
        // In conversation mode - buffer speech and wait for silence
        if (result.isFinal) {
          // If we're processing and user speaks more, cancel and concatenate
          if (isProcessing && pendingAbortController) {
            console.log('User spoke during processing - canceling request');
            pendingAbortController.abort();
            pendingAbortController = null;
            isProcessing = false;
            // Concatenate with previous buffer
            speechBuffer = speechBuffer ? speechBuffer + ' ' + transcript : transcript;
          } else {
            speechBuffer = transcript;
          }
          console.log('Buffered:', speechBuffer);

          // Clear any existing timeout
          if (speechTimeout) clearTimeout(speechTimeout);

          // Wait for silence before processing
          setVoiceState('conversation', 'Listening...');
          speechTimeout = setTimeout(() => {
            if (speechBuffer && !isSpeaking) {
              const textToProcess = speechBuffer;
              speechBuffer = '';
              processVoiceInput(textToProcess);
            }
          }, SILENCE_DELAY);
        } else {
          // Show interim results
          const displayText = isProcessing ? `Adding: "${transcript}..."` : `"${transcript}..."`;
          setVoiceState('conversation', displayText);
          // Reset the silence timer on interim results
          if (speechTimeout) clearTimeout(speechTimeout);

          // If processing and user starts talking, prepare to cancel
          if (isProcessing && pendingAbortController) {
            console.log('User starting to speak during processing...');
          }
        }
      }
    }

    function handleSpeechError(event) {
      console.log('Speech error:', event.error, 'isSpeaking:', isSpeaking);
      if (event.error === 'not-allowed') {
        micPermissionGranted = false;
        setVoiceState('idle', 'Tap mic for permission');
      } else if (event.error === 'no-speech') {
        // Only restart if not speaking
        if (!isSpeaking) {
          setTimeout(startListening, 500);
        }
      } else if (event.error === 'aborted') {
        // Aborted intentionally - don't restart automatically
        console.log('Speech aborted (intentional)');
      } else if (event.error === 'network') {
        setVoiceState('idle', 'Network error - tap to retry');
      }
    }

    function handleSpeechEnd() {
      console.log('Speech recognition ended, voiceMode:', voiceMode, 'isSpeaking:', isSpeaking);
      // Restart listening ONLY if not speaking
      if (!isSpeaking) {
        setTimeout(startListening, 500);
      }
    }

    function startConversation() {
      inConversation = true;
      setVoiceState('conversation', 'Listening...');
      applyEmotion('happy');

      // Greet the user
      speak("Hey! What's up?");
    }

    function endConversation() {
      inConversation = false;
      setVoiceState('listening', 'Say "Hey E-NOR"');
      applyEmotion('happy');
    }

    async function processVoiceInput(text) {
      if (!text || text.length < 2) return;

      // Check for goodbye phrases
      const goodbyePhrases = ['goodbye', 'bye bye', 'bye e-nor', 'bye enor', 'see you',
                              'see ya', 'talk later', 'that\'s all', 'i\'m done', 'finished'];
      const isGoodbye = goodbyePhrases.some(phrase => text.includes(phrase));

      // Add user message to chat
      addMessage(text, 'user');

      // Show thinking - but KEEP listening so user can add more
      setVoiceState('conversation', 'Thinking... (keep talking to add more)');
      applyEmotion('thinking');

      // Create abort controller for this request
      pendingAbortController = new AbortController();
      isProcessing = true;

      try {
        const response = await fetch('/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message: text,
            conversation_id: conversationId
          }),
          signal: pendingAbortController.signal
        });

        const data = await response.json();
        isProcessing = false;
        pendingAbortController = null;

        // Add to chat
        addMessage(data.response, 'enor');

        // Update emotion
        if (data.emotion && emotions[data.emotion]) {
          applyEmotion(data.emotion);
          send({ type: 'emotion', emotion: data.emotion });
        }

        // Speak the response
        await speak(data.response);

        // Check if this was a goodbye
        if (isGoodbye || data.response.toLowerCase().includes('goodbye') ||
            data.response.toLowerCase().includes('bye')) {
          endConversation();
        } else {
          // Continue conversation
          setVoiceState('conversation', 'Listening...');
          startListening();
        }

      } catch (error) {
        isProcessing = false;
        pendingAbortController = null;

        // Check if this was an intentional abort (user kept talking)
        if (error.name === 'AbortError') {
          console.log('Request canceled - user is still talking');
          setVoiceState('conversation', 'Listening...');
          // Don't speak error, just let the new combined text be processed
          return;
        }

        console.error('Chat error:', error);
        await speak("Sorry, my brain got confused. Can you try again?");
        applyEmotion('sad');
        setVoiceState('conversation', 'Listening...');
        startListening();
      }
    }

    function speak(text) {
      return new Promise((resolve) => {
        if (!synthesis) {
          resolve();
          return;
        }

        // Stop listening while speaking to prevent echo
        isSpeaking = true;
        stopListening();
        speechBuffer = '';
        if (speechTimeout) clearTimeout(speechTimeout);

        // Cancel any ongoing speech
        synthesis.cancel();

        setVoiceState('speaking', 'Speaking...');

        // Show interrupt button
        const interruptBtn = document.getElementById('interrupt-btn');
        interruptBtn.classList.add('visible');

        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 1.0;
        utterance.pitch = 1.1;
        utterance.volume = 1.0;

        // Try to find a good voice
        const voices = synthesis.getVoices();
        const preferredVoice = voices.find(v =>
          v.name.includes('Daniel') ||
          v.name.includes('Google UK English Male') ||
          v.name.includes('English United Kingdom')
        ) || voices.find(v => v.lang.startsWith('en'));

        if (preferredVoice) {
          utterance.voice = preferredVoice;
        }

        utterance.onend = () => {
          isSpeaking = false;
          // Hide interrupt button
          interruptBtn.classList.remove('visible');
          // Wait a moment before resuming listening to avoid catching echo
          setTimeout(() => {
            if (inConversation && !isSpeaking) {
              setVoiceState('conversation', 'Listening...');
              startListening();
            } else if (!inConversation) {
              setVoiceState('listening', 'Say "Hey E-NOR"');
              startListening();
            }
          }, 500);
          resolve();
        };

        utterance.onerror = (e) => {
          console.log('Speech error:', e);
          isSpeaking = false;
          interruptBtn.classList.remove('visible');
          resolve();
        };

        synthesis.speak(utterance);
      });
    }

    function interruptSpeech() {
      if (isSpeaking && synthesis) {
        synthesis.cancel();
        isSpeaking = false;
        // Hide interrupt button
        document.getElementById('interrupt-btn').classList.remove('visible');
        if (inConversation) {
          setVoiceState('conversation', 'Listening...');
          setTimeout(() => startListening(), 300);
        }
      }
    }

    async function toggleVoiceMode() {
      if (!voiceSupported) return;

      // If speaking, interrupt
      if (isSpeaking) {
        interruptSpeech();
        return;
      }

      if (inConversation) {
        // End conversation
        speak("Okay, talk to you later!").then(() => {
          endConversation();
        });
      } else {
        // Request mic permission first if needed
        if (!micPermissionGranted) {
          const granted = await requestMicPermission();
          if (!granted) return;
        }
        // Start conversation directly
        startConversation();
      }
    }

    // ==================== Init ====================
    // Add welcome message on load
    addMessage("Hi Ronnie! I'm E-NOR. Say 'Hey E-NOR' to start talking, or type below!", 'enor');

    // Connect WebSocket
    connect();

    // Check chat status on load
    fetch('/api/chat/status').then(r => r.json()).then(data => {
      if (!data.ready) {
        addMessage("Tap the gear icon to add my Claude API key so I can chat with you!", 'system');
      }
    }).catch(() => {});

    // Keep screen awake
    if ('wakeLock' in navigator) {
      navigator.wakeLock.request('screen').catch(() => {});
    }

    // Load voices for TTS
    if (synthesis) {
      synthesis.getVoices();
      // Chrome needs this event
      speechSynthesis.onvoiceschanged = () => synthesis.getVoices();
    }

    // Show initial voice state
    if (voiceSupported) {
      setVoiceState('idle', 'Tap mic to enable voice');
    }

    // Request mic permission on first user interaction anywhere
    document.addEventListener('click', async function initVoice(e) {
      // Don't trigger on settings modal clicks
      if (document.getElementById('settings-modal').contains(e.target)) return;

      if (voiceSupported && !micPermissionGranted) {
        console.log('First click - requesting mic permission');
        const granted = await requestMicPermission();
        if (granted) {
          startListening();
        }
      }
      document.removeEventListener('click', initVoice);
    }, { once: true });
  </script>
</body>
</html>
