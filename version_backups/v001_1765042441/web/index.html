<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>E-NOR</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      height: 100dvh; /* dynamic viewport height - accounts for browser bars */
      overflow: hidden;
      display: flex;
      flex-direction: column;
      font-family: Arial, sans-serif;
      background: #1a1a2e;
      transition: background-color 0.1s;
    }

    /* Startup overlay - covers everything during boot */
    #startup-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #1a1a2e;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 1s ease-out;
    }
    #startup-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    /* Boot sequence phases */
    #startup-face {
      opacity: 0;
      transform: scale(0.8);
      transition: all 1.5s ease-out;
    }
    #startup-face.phase1 {
      opacity: 0.3;
      transform: scale(0.9);
    }
    #startup-face.phase2 {
      opacity: 0.7;
      transform: scale(0.95);
    }
    #startup-face.visible {
      opacity: 1;
      transform: scale(1);
    }

    /* Eye flicker animation for boot effect */
    @keyframes eyeFlicker {
      0%, 100% { opacity: 1; }
      10% { opacity: 0.3; }
      20% { opacity: 0.8; }
      30% { opacity: 0.2; }
      40% { opacity: 0.9; }
      50% { opacity: 0.4; }
      60% { opacity: 1; }
      70% { opacity: 0.5; }
      80% { opacity: 0.9; }
      90% { opacity: 0.7; }
    }

    #startup-face.flickering .eye {
      animation: eyeFlicker 0.8s ease-in-out;
    }

    /* Ring pulse animation */
    @keyframes ringPulse {
      0% { stroke-opacity: 0.2; }
      50% { stroke-opacity: 0.8; }
      100% { stroke-opacity: 0.4; }
    }

    #startup-face .ring {
      animation: ringPulse 2s ease-in-out infinite;
    }

    /* Gentle eye blink during wake */
    @keyframes wakeBlink {
      0% { transform: scaleY(0.1); }
      50% { transform: scaleY(1); }
      60% { transform: scaleY(0.1); }
      100% { transform: scaleY(1); }
    }

    #startup-face.waking .eye-group {
      transform-origin: center;
      animation: wakeBlink 1.5s ease-in-out forwards;
    }

    #startup-name {
      font-size: 28px;
      font-weight: bold;
      letter-spacing: 8px;
      color: #00ffff;
      text-shadow: 0 0 20px #00ffff;
      margin-top: 20px;
      opacity: 0;
      transform: translateY(20px);
      transition: all 1.2s ease-out;
    }
    #startup-name.visible {
      opacity: 1;
      transform: translateY(0);
    }
    #startup-name.glow {
      animation: nameGlow 2s ease-in-out infinite;
    }
    @keyframes nameGlow {
      0%, 100% { text-shadow: 0 0 20px #00ffff; }
      50% { text-shadow: 0 0 40px #00ffff, 0 0 60px #00ffff; }
    }

    #startup-status {
      margin-top: 30px;
      color: #666;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.5s, color 0.5s;
    }
    #startup-status.visible {
      opacity: 1;
    }
    #startup-status.ready {
      color: #00ffff;
    }

    /* Loading dots animation */
    @keyframes loadingDots {
      0%, 20% { content: '.'; }
      40% { content: '..'; }
      60% { content: '...'; }
      80%, 100% { content: ''; }
    }

    /* Top section: Face */
    #face-container {
      flex: 1;
      min-height: 180px;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.8s ease-out;
    }
    #face-container.visible {
      opacity: 1;
    }
    /* When chat is visible, face takes less space */
    body.chat-visible #face-container {
      flex: 0 0 45%;
    }
    #face-svg { transition: transform 0.1s; }
    #face-svg.disco-bounce {
      animation: discoBounce 0.5s ease-in-out infinite;
    }
    @keyframes discoBounce {
      0%, 100% { transform: translateY(0) rotate(0deg) scale(1); }
      25% { transform: translateY(-10px) rotate(-3deg) scale(1.03); }
      50% { transform: translateY(0) rotate(0deg) scale(1); }
      75% { transform: translateY(-10px) rotate(3deg) scale(1.03); }
    }
    #name {
      font-size: 20px;
      font-weight: bold;
      letter-spacing: 6px;
      color: #00ffff;
      text-shadow: 0 0 15px #00ffff;
      margin-top: 5px;
    }
    #name.disco-shake {
      animation: discoShake 0.3s ease-in-out infinite;
    }
    @keyframes discoShake {
      0%, 100% { transform: translateX(0) scale(1); }
      25% { transform: translateX(-5px) scale(1.05); }
      75% { transform: translateX(5px) scale(1.05); }
    }

    /* Status and Settings */
    #status {
      position: absolute;
      top: 10px;
      right: 45px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ff4444;
    }
    #status.connected { background: #00ff00; }

    #settings-btn {
      position: absolute;
      top: 8px;
      right: 10px;
      font-size: 24px;
      background: none;
      border: none;
      cursor: pointer;
      opacity: 0.7;
      padding: 0;
    }
    #settings-btn:hover { opacity: 1; }

    #versions-btn {
      position: absolute;
      top: 8px;
      right: 50px;
      font-size: 20px;
      background: none;
      border: none;
      cursor: pointer;
      opacity: 0.7;
      padding: 2px;
    }
    #versions-btn:hover { opacity: 1; }

    /* Bottom section: Chat - hidden by default */
    #chat-container {
      flex: 1;
      min-height: 0; /* important for flex scroll */
      display: none;
      flex-direction: column;
      background: #0d0d1a;
      border-top: 2px solid #333;
    }
    body.chat-visible #chat-container {
      display: flex;
    }

    #chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .message {
      max-width: 85%;
      padding: 10px 14px;
      border-radius: 18px;
      font-size: 14px;
      line-height: 1.4;
      word-wrap: break-word;
    }
    .message.user {
      align-self: flex-end;
      background: #0066cc;
      color: white;
      border-bottom-right-radius: 4px;
    }
    .message.enor {
      align-self: flex-start;
      background: #333;
      color: #00ffff;
      border-bottom-left-radius: 4px;
    }
    .message.enor.thinking {
      background: #222;
      color: #888;
      font-style: italic;
    }
    .message.system {
      align-self: center;
      background: #442222;
      color: #ffaa88;
      font-size: 12px;
      max-width: 95%;
    }
    .message.system code {
      background: #333;
      padding: 2px 6px;
      border-radius: 4px;
      font-family: monospace;
      color: #00ffff;
    }
    .message.system strong {
      color: #ffcc88;
    }

    #chat-input-container {
      display: flex;
      gap: 8px;
      padding: 10px;
      background: #1a1a2e;
      border-top: 1px solid #333;
    }

    #chat-input {
      flex: 1;
      padding: 12px 16px;
      font-size: 16px;
      border: 2px solid #333;
      border-radius: 25px;
      background: #0d0d1a;
      color: white;
      outline: none;
    }
    #chat-input:focus {
      border-color: #00ffff;
    }
    #chat-input::placeholder {
      color: #666;
    }

    #send-btn {
      padding: 12px 20px;
      font-size: 16px;
      background: #00ffff;
      color: #000;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      font-weight: bold;
    }
    #send-btn:disabled {
      background: #333;
      color: #666;
      cursor: not-allowed;
    }

    /* Quick actions */
    #quick-actions {
      display: flex;
      gap: 6px;
      padding: 6px 10px;
      overflow-x: auto;
      background: #0d0d1a;
    }
    .quick-btn {
      padding: 6px 12px;
      font-size: 11px;
      background: #222;
      color: #aaa;
      border: 1px solid #444;
      border-radius: 15px;
      cursor: pointer;
      white-space: nowrap;
    }
    .quick-btn:hover {
      background: #333;
      color: #fff;
    }
    #disco-btn.active { background: #ff00ff; color: #000; border-color: #ff00ff; }

    /* Voice indicator */
    #voice-status {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 15px;
      font-size: 11px;
      background: #222;
      color: #888;
    }
    #voice-status.listening {
      background: #002200;
      color: #00ff00;
    }
    #voice-status.conversation {
      background: #220022;
      color: #ff00ff;
      animation: pulse 1s infinite;
    }
    #voice-status.speaking {
      background: #002222;
      color: #00ffff;
    }
    #voice-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #666;
    }
    #voice-status.listening #voice-dot { background: #00ff00; }
    #voice-status.conversation #voice-dot { background: #ff00ff; }
    #voice-status.speaking #voice-dot { background: #00ffff; }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    /* Mic button */
    #mic-btn {
      padding: 12px;
      font-size: 20px;
      background: #333;
      color: #fff;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #mic-btn.active {
      background: #ff00ff;
      animation: pulse 1s infinite;
    }
    #mic-btn.speaking {
      background: #ff4444;
      animation: none;
    }
    #mic-btn:disabled {
      background: #222;
      color: #555;
      cursor: not-allowed;
    }

    /* Interrupt Button - shows during speech */
    #interrupt-btn {
      display: none;
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      padding: 15px 30px;
      font-size: 16px;
      font-weight: bold;
      background: #ff4444;
      color: white;
      border: none;
      border-radius: 30px;
      cursor: pointer;
      z-index: 100;
      box-shadow: 0 4px 15px rgba(255,68,68,0.5);
      animation: pulseInterrupt 1s infinite;
    }
    #interrupt-btn.visible {
      display: block;
    }
    @keyframes pulseInterrupt {
      0%, 100% { transform: translateX(-50%) scale(1); }
      50% { transform: translateX(-50%) scale(1.05); }
    }

    /* Settings Modal */
    #settings-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      z-index: 1000;
      flex-direction: column;
      padding: 20px;
      overflow-y: auto;
    }
    #settings-modal.visible { display: flex; }

    #settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    #settings-header h2 {
      color: #00ffff;
      font-size: 20px;
    }
    #close-settings {
      font-size: 28px;
      background: none;
      border: none;
      color: #fff;
      cursor: pointer;
    }

    .secret-item {
      background: #1a1a2e;
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 15px;
    }
    .secret-item h3 {
      color: #fff;
      font-size: 14px;
      margin-bottom: 5px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .secret-item .hint {
      color: #888;
      font-size: 12px;
      margin-bottom: 10px;
    }
    .secret-item .status-icon {
      font-size: 16px;
    }
    .secret-item .status-icon.configured { color: #00ff00; }
    .secret-item .status-icon.missing { color: #ff4444; }

    .secret-form {
      display: flex;
      gap: 8px;
    }
    .secret-form input {
      flex: 1;
      padding: 10px;
      border: 1px solid #333;
      border-radius: 8px;
      background: #0d0d1a;
      color: #fff;
      font-size: 14px;
    }
    .secret-form input::placeholder { color: #666; }
    .secret-form button {
      padding: 10px 15px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
    }
    .secret-form .save-btn {
      background: #00ff00;
      color: #000;
    }
    .secret-form .delete-btn {
      background: #ff4444;
      color: #fff;
    }

    #test-connection {
      width: 100%;
      padding: 15px;
      background: #333;
      color: #fff;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      cursor: pointer;
      margin-top: 10px;
    }
    #test-connection:hover { background: #444; }

    #connection-result {
      text-align: center;
      padding: 10px;
      margin-top: 10px;
      border-radius: 8px;
      font-size: 14px;
    }
    #connection-result.success { background: #224422; color: #00ff00; }
    #connection-result.error { background: #442222; color: #ff4444; }

    /* Dev Mode Toggle */
    .dev-mode-toggle {
      background: #1a1a2e;
      border-radius: 10px;
      padding: 15px;
      margin-top: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .dev-mode-toggle h3 {
      color: #fff;
      font-size: 14px;
      margin: 0;
    }
    .dev-mode-toggle p {
      color: #888;
      font-size: 12px;
      margin: 5px 0 0 0;
    }
    .toggle-switch {
      position: relative;
      width: 50px;
      height: 26px;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #333;
      border-radius: 26px;
      transition: 0.3s;
    }
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 3px;
      bottom: 3px;
      background: #fff;
      border-radius: 50%;
      transition: 0.3s;
    }
    .toggle-switch input:checked + .toggle-slider {
      background: #00ff00;
    }
    .toggle-switch input:checked + .toggle-slider:before {
      transform: translateX(24px);
    }

    /* Versions Modal */
    #versions-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      z-index: 1000;
      flex-direction: column;
      padding: 20px;
      overflow-y: auto;
    }
    #versions-modal.visible { display: flex; }

    #versions-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    #versions-header h2 {
      color: #00ffff;
      font-size: 20px;
    }
    #close-versions {
      font-size: 28px;
      background: none;
      border: none;
      color: #fff;
      cursor: pointer;
      opacity: 0.7;
    }
    #close-versions:hover { opacity: 1; }

    .version-item {
      background: #1a1a2e;
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 10px;
      border-left: 4px solid #333;
    }
    .version-item.current {
      border-left-color: #00ff00;
      background: #0d1a0d;
    }
    .version-item.working { border-left-color: #00ff00; }
    .version-item.broken { border-left-color: #ff4444; }
    .version-item.testing { border-left-color: #ffaa00; }

    .version-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .version-title {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .version-number {
      background: #333;
      color: #fff;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: bold;
    }
    .version-status {
      font-size: 18px;
    }
    .version-description {
      color: #ccc;
      font-size: 16px;
      margin-bottom: 5px;
    }
    .version-time {
      color: #888;
      font-size: 12px;
    }
    .version-actions {
      margin-top: 10px;
      display: flex;
      gap: 10px;
    }
    .version-btn {
      padding: 8px 15px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      font-weight: bold;
    }
    .rollback-btn {
      background: #ff6600;
      color: #fff;
    }
    .rollback-btn:hover { background: #ff8833; }
    .rollback-btn:disabled {
      background: #333;
      color: #666;
      cursor: not-allowed;
    }
    .status-btn {
      background: #333;
      color: #ccc;
    }
    .status-btn:hover { background: #444; }

    #current-version-info {
      background: #0d1a0d;
      border: 1px solid #00ff00;
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 20px;
    }
    #current-version-info h3 {
      color: #00ff00;
      margin: 0 0 10px 0;
      font-size: 16px;
    }

    /* Dev Console Panel */
    #dev-console {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 35%;
      background: rgba(0, 0, 0, 0.95);
      border-top: 2px solid #00ff00;
      z-index: 999;
      flex-direction: column;
    }
    #dev-console.visible {
      display: flex;
    }
    #dev-console-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: #111;
      border-bottom: 1px solid #333;
    }
    #dev-console-header h4 {
      color: #00ff00;
      font-size: 12px;
      margin: 0;
      font-family: monospace;
    }
    #dev-console-header button {
      background: #333;
      border: none;
      color: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
      margin-left: 8px;
    }
    #dev-console-header button:hover {
      background: #444;
    }
    #console-output {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
      font-family: monospace;
      font-size: 11px;
    }
    .console-line {
      padding: 3px 0;
      border-bottom: 1px solid #222;
      word-break: break-all;
    }
    .console-line.log { color: #aaa; }
    .console-line.info { color: #00ffff; }
    .console-line.warn { color: #ffaa00; }
    .console-line.error { color: #ff4444; }
    .console-line.speech { color: #ff00ff; }
    .console-line .timestamp {
      color: #666;
      margin-right: 8px;
    }
    #speech-preview {
      padding: 8px 12px;
      background: #1a001a;
      border-top: 1px solid #333;
      font-family: monospace;
      font-size: 12px;
      color: #ff00ff;
    }
    #speech-preview strong {
      color: #ff88ff;
    }
    /* Tap to start overlay - requires user gesture to unlock audio */
    #tap-to-start {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #1a1a2e;
      z-index: 10000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: opacity 0.5s ease-out;
    }
    #tap-to-start.hidden {
      opacity: 0;
      pointer-events: none;
    }
    #tap-to-start .tap-icon {
      width: 120px;
      height: 120px;
      border: 4px solid #00ffff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: tapPulse 2s ease-in-out infinite;
    }
    @keyframes tapPulse {
      0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(0, 255, 255, 0.3); }
      50% { transform: scale(1.05); box-shadow: 0 0 40px rgba(0, 255, 255, 0.5); }
    }
    #tap-to-start .tap-icon svg {
      width: 60px;
      height: 60px;
      fill: #00ffff;
    }
    #tap-to-start .tap-text {
      margin-top: 30px;
      color: #00ffff;
      font-size: 18px;
      letter-spacing: 2px;
    }
    #tap-to-start .tap-hint {
      margin-top: 10px;
      color: #666;
      font-size: 12px;
    }

    /* Pending Requests Badge */
    #pending-badge {
      position: absolute;
      top: 10px;
      right: 80px;
      display: none;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 15px;
      font-size: 11px;
      background: #1a1a00;
      color: #ffaa00;
      cursor: pointer;
      border: 1px solid #ffaa00;
      animation: pendingPulse 2s ease-in-out infinite;
    }
    #pending-badge.visible {
      display: flex;
    }
    #pending-badge:hover {
      background: #2a2a00;
    }
    @keyframes pendingPulse {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }

    /* Pending Requests Panel */
    #pending-panel {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 400px;
      max-height: 70%;
      background: #1a1a2e;
      border: 2px solid #ffaa00;
      border-radius: 15px;
      z-index: 1001;
      flex-direction: column;
      overflow: hidden;
    }
    #pending-panel.visible {
      display: flex;
    }
    #pending-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      background: #0d0d1a;
      border-bottom: 1px solid #333;
    }
    #pending-panel-header h3 {
      color: #ffaa00;
      font-size: 16px;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #close-pending {
      font-size: 24px;
      background: none;
      border: none;
      color: #fff;
      cursor: pointer;
    }
    #pending-list {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
    }
    .pending-item {
      background: #0d0d1a;
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 10px;
      border-left: 3px solid #ffaa00;
    }
    .pending-item.completed {
      border-left-color: #00ff00;
      opacity: 0.7;
    }
    .pending-item .title {
      color: #fff;
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    .pending-item .status {
      font-size: 11px;
      color: #ffaa00;
      text-transform: uppercase;
    }
    .pending-item.completed .status {
      color: #00ff00;
    }
    .pending-item .issue-link {
      font-size: 11px;
      color: #00ffff;
      text-decoration: none;
      margin-left: 10px;
    }
    .pending-item .time {
      font-size: 10px;
      color: #666;
      margin-top: 5px;
    }
    #pending-empty {
      text-align: center;
      padding: 30px;
      color: #666;
    }
    #pending-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      z-index: 1000;
    }
    #pending-overlay.visible {
      display: block;
    }
  </style>
</head>
<body>
  <!-- Tap to Start - Required for audio unlock on mobile -->
  <div id="tap-to-start">
    <div class="tap-icon">
      <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M9 11.24V7.5C9 6.12 10.12 5 11.5 5S14 6.12 14 7.5v3.74c1.21-.81 2-2.18 2-3.74C16 5.01 13.99 3 11.5 3S7 5.01 7 7.5c0 1.56.79 2.93 2 3.74zm9.84 4.63l-4.54-2.26c-.17-.07-.35-.11-.54-.11H13v-6c0-.83-.67-1.5-1.5-1.5S10 6.67 10 7.5v10.74l-3.43-.72c-.08-.01-.15-.03-.24-.03-.31 0-.59.13-.79.33l-.79.8 4.94 4.94c.27.27.65.44 1.06.44h6.79c.75 0 1.33-.55 1.44-1.28l.75-5.27c.01-.07.02-.14.02-.21 0-.59-.34-1.15-.91-1.41z"/>
      </svg>
    </div>
    <div class="tap-text">TAP TO WAKE E-NOR</div>
    <div class="tap-hint">Required for voice on mobile</div>
  </div>

  <!-- Startup Animation Overlay -->
  <div id="startup-overlay">
    <svg id="startup-face" width="200" height="200" viewBox="0 0 400 400">
      <!-- Ring that pulses -->
      <circle class="ring" cx="200" cy="200" r="180" fill="none" stroke="#00ffff" stroke-width="8" opacity="0.4"/>
      <!-- Eyes that can flicker and blink -->
      <g class="eye-group">
        <ellipse class="eye" cx="140" cy="140" rx="35" ry="30" fill="#00ffff"/>
        <ellipse class="pupil" cx="145" cy="145" rx="12" ry="12" fill="#000"/>
        <ellipse class="eye" cx="260" cy="140" rx="35" ry="30" fill="#00ffff"/>
        <ellipse class="pupil" cx="265" cy="145" rx="12" ry="12" fill="#000"/>
      </g>
      <!-- Mouth -->
      <path class="mouth" d="M 120 220 Q 200 280 280 220" stroke="#00ffff" stroke-width="6" stroke-linecap="round" fill="none"/>
    </svg>
    <div id="startup-name">E-NOR</div>
    <div id="startup-status">Waking up...</div>
  </div>

  <!-- Top: Face -->
  <div id="face-container">
    <div id="voice-status">
      <div id="voice-dot"></div>
      <span id="voice-text">Say "Hey E-NOR"</span>
    </div>
    <div id="pending-badge" onclick="openPendingPanel()">
      <span>&#9881;</span>
      <span id="pending-count">0</span> pending
    </div>
    <div id="status"></div>
    <button id="versions-btn" onclick="openVersions()">üìù</button>
    <button id="settings-btn" onclick="openSettings()">&#9881;</button>

    <svg id="face-svg" width="200" height="200" viewBox="0 0 400 400">
      <circle id="ring" cx="200" cy="200" r="180" fill="none" stroke="#00ffff" stroke-width="8" opacity="0.4"/>
      <g id="leds"></g>
      <line id="left-brow" x1="110" y1="105" x2="170" y2="105" stroke="#00ffff" stroke-width="6" stroke-linecap="round"/>
      <line id="right-brow" x1="230" y1="105" x2="290" y2="105" stroke="#00ffff" stroke-width="6" stroke-linecap="round"/>
      <ellipse id="left-eye" cx="140" cy="140" rx="35" ry="30" fill="#00ffff"/>
      <ellipse id="left-pupil" cx="145" cy="145" rx="12" ry="12" fill="#000"/>
      <ellipse id="right-eye" cx="260" cy="140" rx="35" ry="30" fill="#00ffff"/>
      <ellipse id="right-pupil" cx="265" cy="145" rx="12" ry="12" fill="#000"/>
      <path id="mouth" d="M 120 220 Q 200 280 280 220" stroke="#00ffff" stroke-width="6" stroke-linecap="round" fill="none"/>
    </svg>

    <div id="name">E-NOR</div>
  </div>

  <!-- Bottom: Chat -->
  <div id="chat-container">
    <div id="quick-actions">
      <button class="quick-btn" onclick="setEmotion('happy')">Happy</button>
      <button class="quick-btn" onclick="setEmotion('sad')">Sad</button>
      <button class="quick-btn" onclick="setEmotion('surprised')">Surprised</button>
      <button class="quick-btn" onclick="setEmotion('thinking')">Thinking</button>
      <button class="quick-btn" onclick="setEmotion('glitchy')">Glitchy</button>
      <button class="quick-btn" onclick="setEmotion('sparkling')">Sparkling</button>
      <button class="quick-btn" onclick="setEmotion('laser-focused')">Laser Focus</button>
      <button class="quick-btn" onclick="setEmotion('processing')">Processing</button>
      <button class="quick-btn" onclick="setEmotion('overclocked')">Overclocked</button>
      <button class="quick-btn" onclick="toggleDisco()" id="disco-btn">DISCO</button>
    </div>

    <div id="chat-messages">
      <!-- Messages will appear here -->
    </div>

    <div id="chat-input-container">
      <button id="mic-btn" onclick="toggleVoiceMode()">&#127908;</button>
      <input type="text" id="chat-input" placeholder="Say something to E-NOR..." autocomplete="off">
      <button id="send-btn" onclick="sendMessage()">Send</button>
    </div>
  </div>

  <!-- Interrupt button - outside chat so visible when chat hidden -->
  <button id="interrupt-btn" onclick="interruptSpeech()">TAP TO INTERRUPT</button>

  <!-- Settings Modal -->
  <div id="settings-modal">
    <div id="settings-header">
      <h2>E-NOR Settings</h2>
      <button id="close-settings" onclick="closeSettings()">&times;</button>
    </div>

    <div id="secrets-list">
      <!-- Secrets will be loaded here -->
    </div>

    <button id="test-connection" onclick="testConnection()">Test Chat Connection</button>
    <div id="connection-result"></div>

    <!-- Voice Selection -->
    <div class="secret-item">
      <h3>Voice Selection</h3>
      <p class="hint">Choose E-NOR's voice from available options</p>
      <div style="display: flex; gap: 8px; align-items: center;">
        <select id="voice-selector" style="flex: 1; padding: 10px; border: 1px solid #333; border-radius: 8px; background: #0d0d1a; color: #fff; font-size: 14px;" onchange="changeVoice()">
          <option value="">Loading voices...</option>
        </select>
        <button onclick="testSelectedVoice()" style="padding: 10px 15px; border: none; border-radius: 8px; background: #00ff00; color: #000; cursor: pointer; font-weight: bold;">Test</button>
      </div>
    </div>

    <div class="dev-mode-toggle">
      <div>
        <h3>Developer Mode</h3>
        <p>Show on-screen console & speech debug</p>
      </div>
      <label class="toggle-switch">
        <input type="checkbox" id="dev-mode-checkbox" onchange="toggleDevMode()">
        <span class="toggle-slider"></span>
      </label>
    </div>
  </div>

  <!-- Versions Modal -->
  <div id="versions-modal">
    <div id="versions-header">
      <h2>üìù E-NOR Version History</h2>
      <button id="close-versions" onclick="closeVersions()">&times;</button>
    </div>

    <div id="current-version-info">
      <h3>‚úÖ Currently Running</h3>
      <div id="current-version-display">Loading...</div>
    </div>

    <div id="versions-list">
      <!-- Versions will be loaded here -->
    </div>
  </div>

  <!-- Pending Requests Panel -->
  <div id="pending-overlay" onclick="closePendingPanel()"></div>
  <div id="pending-panel">
    <div id="pending-panel-header">
      <h3>&#128736; Code Updates</h3>
      <button id="close-pending" onclick="closePendingPanel()">&times;</button>
    </div>
    <div id="pending-list">
      <!-- Pending requests loaded here -->
    </div>
  </div>

  <!-- Dev Console -->
  <div id="dev-console">
    <div id="dev-console-header">
      <h4>E-NOR Dev Console</h4>
      <div>
        <button onclick="copyDevConsole()" id="copy-btn">Copy</button>
        <button onclick="clearDevConsole()">Clear</button>
        <button onclick="toggleDevMode()">Close</button>
      </div>
    </div>
    <div id="console-output">
      <!-- Console logs appear here -->
    </div>
    <div id="speech-preview">
      <strong>Speech:</strong> <span id="speech-text">Waiting for speech...</span>
    </div>
  </div>

  <script>
    // ==================== Dev Console ====================
    let devModeEnabled = localStorage.getItem('devMode') === 'true';
    const devConsole = document.getElementById('dev-console');
    const consoleOutput = document.getElementById('console-output');
    const speechTextEl = document.getElementById('speech-text');
    const devModeCheckbox = document.getElementById('dev-mode-checkbox');

    // Restore dev mode state
    if (devModeEnabled) {
      devConsole.classList.add('visible');
      devModeCheckbox.checked = true;
    }

    // Intercept console methods
    const originalConsole = {
      log: console.log.bind(console),
      warn: console.warn.bind(console),
      error: console.error.bind(console),
      info: console.info.bind(console)
    };

    function addToDevConsole(type, args) {
      if (!devModeEnabled) return;

      const line = document.createElement('div');
      line.className = `console-line ${type}`;

      const time = new Date().toLocaleTimeString('en-GB', {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 1
      });

      const message = Array.from(args).map(arg => {
        if (typeof arg === 'object') {
          try {
            return JSON.stringify(arg);
          } catch (e) {
            return String(arg);
          }
        }
        return String(arg);
      }).join(' ');

      line.innerHTML = `<span class="timestamp">${time}</span>${message}`;
      consoleOutput.appendChild(line);

      // Keep only last 100 lines
      while (consoleOutput.children.length > 100) {
        consoleOutput.removeChild(consoleOutput.firstChild);
      }

      // Auto-scroll to bottom
      consoleOutput.scrollTop = consoleOutput.scrollHeight;
    }

    console.log = function(...args) {
      originalConsole.log(...args);
      addToDevConsole('log', args);
    };

    console.warn = function(...args) {
      originalConsole.warn(...args);
      addToDevConsole('warn', args);
    };

    console.error = function(...args) {
      originalConsole.error(...args);
      addToDevConsole('error', args);
    };

    console.info = function(...args) {
      originalConsole.info(...args);
      addToDevConsole('info', args);
    };

    function logSpeech(text, isFinal) {
      if (devModeEnabled && speechTextEl) {
        speechTextEl.textContent = isFinal ? `"${text}" ‚úì` : `"${text}"...`;
      }
    }

    function toggleDevMode() {
      devModeEnabled = !devModeEnabled;
      localStorage.setItem('devMode', devModeEnabled);
      devConsole.classList.toggle('visible', devModeEnabled);
      devModeCheckbox.checked = devModeEnabled;

      if (devModeEnabled) {
        console.log('Dev mode enabled');
      }
    }

    function clearDevConsole() {
      consoleOutput.innerHTML = '';
      speechTextEl.textContent = 'Waiting for speech...';
      console.log('Console cleared');
    }

    function copyDevConsole() {
      const lines = Array.from(consoleOutput.querySelectorAll('.console-line')).map(line => {
        const timestamp = line.querySelector('.timestamp')?.textContent || '';
        const text = line.textContent.replace(timestamp, '').trim();
        return timestamp + text;
      });
      const speechText = speechTextEl?.textContent || '';
      const fullText = lines.join('\n') + '\n\n[Speech: ' + speechText + ']';

      navigator.clipboard.writeText(fullText).then(() => {
        const copyBtn = document.getElementById('copy-btn');
        copyBtn.textContent = 'Copied!';
        copyBtn.style.background = '#00ff00';
        copyBtn.style.color = '#000';
        setTimeout(() => {
          copyBtn.textContent = 'Copy';
          copyBtn.style.background = '';
          copyBtn.style.color = '';
        }, 1500);
      }).catch(() => {
        alert('Copy failed - try selecting text manually');
      });
    }

    // ==================== WebSocket ====================
    let ws = null;
    const statusEl = document.getElementById('status');

    function connect() {
      const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${protocol}//${location.host}/ws`);

      ws.onopen = () => {
        console.log('Connected to E-NOR');
        statusEl.classList.add('connected');
      };

      ws.onclose = () => {
        console.log('Disconnected, reconnecting...');
        statusEl.classList.remove('connected');
        setTimeout(connect, 2000);
      };

      ws.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        if (msg.type === 'emotion') {
          applyEmotion(msg.emotion);
        } else if (msg.type === 'disco') {
          if (msg.enabled && !discoMode) toggleDisco();
          else if (!msg.enabled && discoMode) toggleDisco();
        } else if (msg.type === 'state') {
          applyEmotion(msg.data.emotion);
          if (msg.data.disco_mode) toggleDisco();
        }
      };
    }

    function send(data) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(data));
      }
    }

    // ==================== Emotions ====================
    const emotions = {
      happy: { eyeH: 30, eyeY: 140, pupilY: 145, mouth: "M 120 220 Q 200 280 280 220", browAngle: 0, color: "#00ffff" },
      sad: { eyeH: 20, eyeY: 150, pupilY: 155, mouth: "M 130 250 Q 200 210 270 250", browAngle: 15, color: "#6688ff" },
      angry: { eyeH: 20, eyeY: 145, pupilY: 150, mouth: "M 140 250 L 200 240 L 260 250", browAngle: -20, color: "#ff4444" },
      surprised: { eyeH: 45, eyeY: 135, pupilY: 150, mouth: "M 170 230 A 30 30 0 1 1 230 230 A 30 30 0 1 1 170 230", browAngle: 0, color: "#ffff00" },
      thinking: { eyeH: 25, eyeY: 145, pupilY: 150, mouth: "M 150 240 Q 200 240 220 235", browAngle: 10, color: "#aa88ff" },
      sleepy: { eyeH: 8, eyeY: 155, pupilY: 155, mouth: "M 160 240 Q 200 250 240 240", browAngle: 5, color: "#88aacc" },
      // New robot-specific emotions
      glitchy: { eyeH: 15, eyeY: 135, pupilY: 140, mouth: "M 130 240 L 200 235 L 270 245 L 190 250 L 260 240", browAngle: -5, color: "#ff00ff" },
      sparkling: { eyeH: 35, eyeY: 138, pupilY: 143, mouth: "M 120 225 Q 160 215 200 225 Q 240 215 280 225", browAngle: -8, color: "#00ffaa" },
      "laser-focused": { eyeH: 12, eyeY: 145, pupilY: 148, mouth: "M 180 245 L 220 245", browAngle: -15, color: "#ff3300" },
      processing: { eyeH: 18, eyeY: 148, pupilY: 152, mouth: "M 160 245 Q 180 240 200 245 Q 220 240 240 245", browAngle: 8, color: "#3366ff" },
      overclocked: { eyeH: 40, eyeY: 132, pupilY: 147, mouth: "M 110 215 Q 200 270 290 215", browAngle: -12, color: "#ffaa00" }
    };

    let currentEmotion = 'happy';
    let discoMode = false;
    let discoHue = 0;
    let audioCtx = null;
    let discoInterval = null;
    let expressionInterval = null;
    const discoEmotions = ['happy', 'surprised', 'happy', 'thinking'];
    let discoEmotionIndex = 0;

    // Create LED circles
    const ledsGroup = document.getElementById('leds');
    for (let i = 0; i < 12; i++) {
      const angle = (i * 30 - 90) * Math.PI / 180;
      const x = 200 + 180 * Math.cos(angle);
      const y = 200 + 180 * Math.sin(angle);
      const led = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      led.setAttribute("cx", x);
      led.setAttribute("cy", y);
      led.setAttribute("r", 8);
      led.setAttribute("fill", "#00ffff");
      led.id = `led-${i}`;
      ledsGroup.appendChild(led);
    }

    function setEmotion(name) {
      if (discoMode) toggleDisco();
      currentEmotion = name;
      applyEmotion(name);
      send({ type: 'emotion', emotion: name });
    }

    function applyEmotion(name) {
      currentEmotion = name;
      const e = emotions[name];
      if (!e) return;

      document.getElementById('left-eye').setAttribute('cy', e.eyeY);
      document.getElementById('left-eye').setAttribute('ry', e.eyeH);
      document.getElementById('right-eye').setAttribute('cy', e.eyeY);
      document.getElementById('right-eye').setAttribute('ry', e.eyeH);
      document.getElementById('left-pupil').setAttribute('cy', e.pupilY);
      document.getElementById('left-pupil').setAttribute('ry', Math.min(12, e.eyeH - 5));
      document.getElementById('right-pupil').setAttribute('cy', e.pupilY);
      document.getElementById('right-pupil').setAttribute('ry', Math.min(12, e.eyeH - 5));
      document.getElementById('mouth').setAttribute('d', e.mouth);

      document.getElementById('left-brow').setAttribute('y1', 105 + e.browAngle);
      document.getElementById('left-brow').setAttribute('y2', 105 - e.browAngle);
      document.getElementById('right-brow').setAttribute('y1', 105 - e.browAngle);
      document.getElementById('right-brow').setAttribute('y2', 105 + e.browAngle);

      setColor(e.color);
    }

    function setColor(color) {
      document.getElementById('ring').setAttribute('stroke', color);
      document.getElementById('left-eye').setAttribute('fill', color);
      document.getElementById('right-eye').setAttribute('fill', color);
      document.getElementById('left-brow').setAttribute('stroke', color);
      document.getElementById('right-brow').setAttribute('stroke', color);
      document.getElementById('mouth').setAttribute('stroke', color);
      document.getElementById('name').style.color = color;
      document.getElementById('name').style.textShadow = `0 0 15px ${color}`;
      for (let i = 0; i < 12; i++) {
        document.getElementById(`led-${i}`).setAttribute('fill', color);
      }
    }

    // ==================== Disco Mode ====================
    function createDiscoMusic() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
      return audioCtx;
    }

    function playDiscoBeat() {
      if (!audioCtx || !discoMode) return;

      const now = audioCtx.currentTime;

      // Kick drum
      const kickOsc = audioCtx.createOscillator();
      const kickGain = audioCtx.createGain();
      kickOsc.type = 'sine';
      kickOsc.frequency.setValueAtTime(150, now);
      kickOsc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
      kickGain.gain.setValueAtTime(0.8, now);
      kickGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
      kickOsc.connect(kickGain);
      kickGain.connect(audioCtx.destination);
      kickOsc.start(now);
      kickOsc.stop(now + 0.2);

      // Hi-hat on off-beats
      setTimeout(() => {
        if (!discoMode) return;
        const hihatOsc = audioCtx.createOscillator();
        const hihatGain = audioCtx.createGain();
        const hihatFilter = audioCtx.createBiquadFilter();
        hihatOsc.type = 'square';
        hihatOsc.frequency.setValueAtTime(800, audioCtx.currentTime);
        hihatFilter.type = 'highpass';
        hihatFilter.frequency.setValueAtTime(7000, audioCtx.currentTime);
        hihatGain.gain.setValueAtTime(0.15, audioCtx.currentTime);
        hihatGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
        hihatOsc.connect(hihatFilter);
        hihatFilter.connect(hihatGain);
        hihatGain.connect(audioCtx.destination);
        hihatOsc.start(audioCtx.currentTime);
        hihatOsc.stop(audioCtx.currentTime + 0.05);
      }, 125);

      // Funky bass note
      const bassNotes = [110, 130.81, 146.83, 164.81];
      const bassNote = bassNotes[Math.floor(Math.random() * bassNotes.length)];
      const bassOsc = audioCtx.createOscillator();
      const bassGain = audioCtx.createGain();
      bassOsc.type = 'sawtooth';
      bassOsc.frequency.setValueAtTime(bassNote, now);
      bassGain.gain.setValueAtTime(0.3, now);
      bassGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
      bassOsc.connect(bassGain);
      bassGain.connect(audioCtx.destination);
      bassOsc.start(now + 0.05);
      bassOsc.stop(now + 0.2);
    }

    function startDiscoMusic() {
      createDiscoMusic();
      playDiscoBeat();
      discoInterval = setInterval(playDiscoBeat, 250);
    }

    function stopDiscoMusic() {
      if (discoInterval) {
        clearInterval(discoInterval);
        discoInterval = null;
      }
    }

    function toggleDisco() {
      discoMode = !discoMode;
      document.getElementById('disco-btn').classList.toggle('active');

      const faceSvg = document.getElementById('face-svg');
      const nameEl = document.getElementById('name');

      if (discoMode) {
        faceSvg.classList.add('disco-bounce');
        nameEl.classList.add('disco-shake');
        startDiscoMusic();

        discoEmotionIndex = 0;
        expressionInterval = setInterval(() => {
          discoEmotionIndex = (discoEmotionIndex + 1) % discoEmotions.length;
          const emotion = discoEmotions[discoEmotionIndex];
          const e = emotions[emotion];

          document.getElementById('left-eye').setAttribute('cy', e.eyeY);
          document.getElementById('left-eye').setAttribute('ry', e.eyeH);
          document.getElementById('right-eye').setAttribute('cy', e.eyeY);
          document.getElementById('right-eye').setAttribute('ry', e.eyeH);
          document.getElementById('left-pupil').setAttribute('cy', e.pupilY);
          document.getElementById('left-pupil').setAttribute('ry', Math.min(12, e.eyeH - 5));
          document.getElementById('right-pupil').setAttribute('cy', e.pupilY);
          document.getElementById('right-pupil').setAttribute('ry', Math.min(12, e.eyeH - 5));
          document.getElementById('mouth').setAttribute('d', e.mouth);
          document.getElementById('left-brow').setAttribute('y1', 105 + e.browAngle);
          document.getElementById('left-brow').setAttribute('y2', 105 - e.browAngle);
          document.getElementById('right-brow').setAttribute('y1', 105 - e.browAngle);
          document.getElementById('right-brow').setAttribute('y2', 105 + e.browAngle);
        }, 500);
      } else {
        faceSvg.classList.remove('disco-bounce');
        nameEl.classList.remove('disco-shake');
        stopDiscoMusic();

        if (expressionInterval) {
          clearInterval(expressionInterval);
          expressionInterval = null;
        }
        applyEmotion('happy');
      }

      send({ type: 'disco', enabled: discoMode });
    }

    // Disco animation loop
    setInterval(() => {
      if (discoMode) {
        discoHue = (discoHue + 3) % 360;
        document.body.style.background = `hsl(${discoHue}, 80%, 15%)`;
        document.getElementById('ring').setAttribute('stroke-width', 15);
        document.getElementById('ring').setAttribute('opacity', 0.9);

        for (let i = 0; i < 12; i++) {
          const ledHue = (discoHue + i * 30) % 360;
          document.getElementById(`led-${i}`).setAttribute('fill', `hsl(${ledHue}, 100%, 60%)`);
          document.getElementById(`led-${i}`).setAttribute('r', 12);
        }

        const mainColor = `hsl(${discoHue}, 100%, 60%)`;
        document.getElementById('left-eye').setAttribute('fill', mainColor);
        document.getElementById('right-eye').setAttribute('fill', mainColor);
        document.getElementById('left-brow').setAttribute('stroke', mainColor);
        document.getElementById('right-brow').setAttribute('stroke', mainColor);
        document.getElementById('mouth').setAttribute('stroke', mainColor);
        document.getElementById('name').style.color = mainColor;
        document.getElementById('name').style.textShadow = `0 0 15px ${mainColor}`;
      } else {
        document.body.style.background = '#1a1a2e';
        document.getElementById('ring').setAttribute('stroke-width', 8);
        document.getElementById('ring').setAttribute('opacity', 0.4);
        for (let i = 0; i < 12; i++) {
          document.getElementById(`led-${i}`).setAttribute('r', 8);
        }
      }
    }, 50);

    // Blinking
    setInterval(() => {
      if (discoMode) return;
      const e = emotions[currentEmotion];
      document.getElementById('left-eye').setAttribute('ry', 3);
      document.getElementById('right-eye').setAttribute('ry', 3);
      document.getElementById('left-pupil').style.display = 'none';
      document.getElementById('right-pupil').style.display = 'none';

      setTimeout(() => {
        document.getElementById('left-eye').setAttribute('ry', e.eyeH);
        document.getElementById('right-eye').setAttribute('ry', e.eyeH);
        document.getElementById('left-pupil').style.display = 'block';
        document.getElementById('right-pupil').style.display = 'block';
      }, 150);
    }, 3000 + Math.random() * 2000);

    // ==================== Chat ====================
    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const sendBtn = document.getElementById('send-btn');
    let conversationId = 'ronnie-' + Date.now();
    let isWaitingForResponse = false;

    function addMessage(text, type) {
      const msg = document.createElement('div');
      msg.className = `message ${type}`;
      msg.textContent = text;
      chatMessages.appendChild(msg);
      chatMessages.scrollTop = chatMessages.scrollHeight;
      return msg;
    }

    async function sendMessage() {
      const text = chatInput.value.trim();
      if (!text || isWaitingForResponse) return;

      // Add user message
      addMessage(text, 'user');
      chatInput.value = '';

      // Show thinking state
      isWaitingForResponse = true;
      sendBtn.disabled = true;
      applyEmotion('thinking');
      const thinkingMsg = addMessage('Thinking...', 'enor thinking');

      try {
        const response = await fetch('/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message: text,
            conversation_id: conversationId
          })
        });

        const data = await response.json();

        // Remove thinking message
        thinkingMsg.remove();

        // Add E-NOR's response
        addMessage(data.response, 'enor');

        // Update emotion based on response
        if (data.emotion && emotions[data.emotion]) {
          applyEmotion(data.emotion);
          send({ type: 'emotion', emotion: data.emotion });
        }
      } catch (error) {
        thinkingMsg.remove();
        addMessage('Oops! Something went wrong. Try again?', 'system');
        applyEmotion('sad');
      }

      isWaitingForResponse = false;
      sendBtn.disabled = false;
      chatInput.focus();
    }

    // Enter key to send
    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    // ==================== Settings ====================
    function openSettings() {
      document.getElementById('settings-modal').classList.add('visible');
      loadSecrets();
      // Ensure voice selector is populated when settings open
      if (synthesis && synthesis.getVoices().length > 0) {
        populateVoiceSelector();
      }
    }

    function closeSettings() {
      document.getElementById('settings-modal').classList.remove('visible');
    }

    // ==================== Versions ====================
    function openVersions() {
      document.getElementById('versions-modal').classList.add('visible');
      loadVersions();
    }

    function closeVersions() {
      document.getElementById('versions-modal').classList.remove('visible');
    }

    async function loadVersions() {
      try {
        const response = await fetch('/api/versions');
        const data = await response.json();
        
        displayCurrentVersion(data.current_version);
        displayVersionsList(data.versions);
      } catch (error) {
        console.error('Error loading versions:', error);
        document.getElementById('current-version-display').innerHTML = 'Error loading versions';
        document.getElementById('versions-list').innerHTML = '<div style="color: #ff4444;">Failed to load version history</div>';
      }
    }

    function displayCurrentVersion(currentVersion) {
      const display = document.getElementById('current-version-display');
      if (currentVersion) {
        display.innerHTML = `
          <div class="version-title">
            <span class="version-number">v${currentVersion.version_number}</span>
            <span class="version-status">${currentVersion.status_emoji}</span>
            <span class="version-description">${currentVersion.description}</span>
          </div>
          <div class="version-time">${currentVersion.time_ago}</div>
        `;
      } else {
        display.innerHTML = 'No version information available';
      }
    }

    function displayVersionsList(versions) {
      const list = document.getElementById('versions-list');
      
      if (!versions || versions.length === 0) {
        list.innerHTML = '<div style="color: #888; text-align: center; padding: 20px;">No version history available</div>';
        return;
      }

      list.innerHTML = versions.map(version => `
        <div class="version-item ${version.is_current ? 'current' : ''} ${version.status}">
          <div class="version-header">
            <div class="version-title">
              <span class="version-number">v${version.version_number}</span>
              <span class="version-status">${version.status_emoji}</span>
              ${version.is_current ? '<span style="color: #00ff00; font-size: 12px; background: rgba(0,255,0,0.1); padding: 2px 6px; border-radius: 3px;">CURRENT</span>' : ''}
            </div>
          </div>
          <div class="version-description">${version.description}</div>
          <div class="version-time">${version.time_ago}</div>
          ${!version.is_current && version.backup_available ? `
            <div class="version-actions">
              <button class="version-btn rollback-btn" onclick="rollbackToVersion('${version.id}', '${version.description}')">
                ‚è™ Go Back to This Version
              </button>
              <button class="version-btn status-btn" onclick="updateVersionStatus('${version.id}', '${version.status === 'working' ? 'broken' : 'working'}')">
                ${version.status === 'working' ? 'Mark as Broken' : 'Mark as Working'}
              </button>
            </div>
          ` : ''}
        </div>
      `).join('');
    }

    async function rollbackToVersion(versionId, description) {
      if (!confirm(`Are you sure you want to go back to "${description}"?\n\nThis will change E-NOR's code back to how it was at that time.`)) {
        return;
      }

      try {
        const response = await fetch(`/api/versions/${versionId}/rollback`, {
          method: 'POST'
        });
        
        const result = await response.json();
        
        if (result.success) {
          alert('‚úÖ Successfully rolled back to previous version!\n\nE-NOR will restart with the older code in about 1 minute.');
          closeVersions();
          // Refresh the page after a short delay to show changes
          setTimeout(() => location.reload(), 2000);
        } else {
          alert('‚ùå Failed to rollback: ' + (result.message || 'Unknown error'));
        }
      } catch (error) {
        console.error('Rollback error:', error);
        alert('‚ùå Error during rollback. Please try again.');
      }
    }

    async function updateVersionStatus(versionId, newStatus) {
      try {
        const response = await fetch(`/api/versions/${versionId}/status`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ status: newStatus })
        });
        
        const result = await response.json();
        
        if (result.success) {
          loadVersions(); // Refresh the list
        } else {
          alert('Failed to update status: ' + (result.message || 'Unknown error'));
        }
      } catch (error) {
        console.error('Status update error:', error);
        alert('Error updating status. Please try again.');
      }
    }

    async function loadSecrets() {
      const secretsList = document.getElementById('secrets-list');

      try {
        const response = await fetch('/api/secrets');
        const data = await response.json();

        secretsList.innerHTML = data.templates.map(template => `
          <div class="secret-item" data-name="${template.name}">
            <h3>
              <span class="status-icon ${template.configured ? 'configured' : 'missing'}">
                ${template.configured ? '&#10004;' : '&#10008;'}
              </span>
              ${template.label}
              ${template.required ? '<span style="color: #ff6666; font-size: 11px;">(required)</span>' : ''}
            </h3>
            <p class="hint">${template.hint}</p>
            <div class="secret-form">
              <input type="password" placeholder="${template.configured ? '******* (saved)' : 'Enter value...'}" id="input-${template.name}">
              <button class="save-btn" onclick="saveSecret('${template.name}')">Save</button>
              ${template.configured ? `<button class="delete-btn" onclick="deleteSecret('${template.name}')">Delete</button>` : ''}
            </div>
          </div>
        `).join('');
      } catch (error) {
        secretsList.innerHTML = '<p style="color: #ff6666;">Could not load settings. Is E-NOR connected?</p>';
      }
    }

    async function saveSecret(name) {
      const input = document.getElementById(`input-${name}`);
      const value = input.value.trim();

      if (!value) {
        alert('Please enter a value');
        return;
      }

      try {
        const response = await fetch('/api/secrets', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, value })
        });

        if (response.ok) {
          input.value = '';
          loadSecrets();
        } else {
          alert('Failed to save secret');
        }
      } catch (error) {
        alert('Could not save secret. Is E-NOR connected?');
      }
    }

    async function deleteSecret(name) {
      if (!confirm(`Delete ${name}?`)) return;

      try {
        const response = await fetch(`/api/secrets/${name}`, {
          method: 'DELETE'
        });

        if (response.ok) {
          loadSecrets();
        } else {
          alert('Failed to delete secret');
        }
      } catch (error) {
        alert('Could not delete secret');
      }
    }

    async function testConnection() {
      const resultEl = document.getElementById('connection-result');
      resultEl.textContent = 'Testing...';
      resultEl.className = '';

      try {
        const response = await fetch('/api/chat/status');
        const data = await response.json();

        if (data.ready) {
          resultEl.textContent = 'Chat is ready! Claude API key is configured.';
          resultEl.className = 'success';
        } else {
          resultEl.textContent = 'Chat not ready: ' + data.message;
          resultEl.className = 'error';
        }
      } catch (error) {
        resultEl.textContent = 'Could not connect to E-NOR server';
        resultEl.className = 'error';
      }
    }

    // ==================== Voice Interface ====================
    const voiceStatus = document.getElementById('voice-status');
    const voiceText = document.getElementById('voice-text');
    const micBtn = document.getElementById('mic-btn');

    let recognition = null;
    let synthesis = window.speechSynthesis;
    let voiceMode = 'idle'; // 'idle', 'listening', 'conversation', 'speaking'
    let inConversation = false;
    let voiceSupported = false;
    let micPermissionGranted = false;
    let isSpeaking = false;
    let speechBuffer = '';
    let speechTimeout = null;
    let pendingAbortController = null; // For canceling requests if user keeps talking
    let isProcessing = false; // True during API call
    const SILENCE_DELAY = 2000; // Wait 2 seconds of silence before processing

    // Voice selection
    let selectedVoice = null;
    let availableVoices = [];
    const voiceSelector = document.getElementById('voice-selector');

    // Load saved voice preference
    function loadVoicePreference() {
      const savedVoiceName = localStorage.getItem('enor-selected-voice');
      if (savedVoiceName && availableVoices.length > 0) {
        const voice = availableVoices.find(v => v.name === savedVoiceName);
        if (voice) {
          selectedVoice = voice;
          voiceSelector.value = savedVoiceName;
          console.log('Restored voice preference:', voice.name);
        }
      }
    }

    // Save voice preference
    function saveVoicePreference(voiceName) {
      localStorage.setItem('enor-selected-voice', voiceName);
      console.log('Saved voice preference:', voiceName);
    }

    // Populate voice selector
    function populateVoiceSelector() {
      availableVoices = synthesis.getVoices();
      console.log('Available voices:', availableVoices.length);
      
      if (availableVoices.length === 0) {
        voiceSelector.innerHTML = '<option value="">No voices available</option>';
        return;
      }

      // Group voices by language/type for better organization
      const englishVoices = availableVoices.filter(v => v.lang.startsWith('en'));
      const otherVoices = availableVoices.filter(v => !v.lang.startsWith('en'));

      let html = '<option value="">Default Voice</option>';
      
      // Add English voices first
      if (englishVoices.length > 0) {
        html += '<optgroup label="English Voices">';
        englishVoices.forEach(voice => {
          const label = `${voice.name} (${voice.lang})`;
          html += `<option value="${voice.name}">${label}</option>`;
        });
        html += '</optgroup>';
      }

      // Add other language voices
      if (otherVoices.length > 0) {
        html += '<optgroup label="Other Languages">';
        otherVoices.forEach(voice => {
          const label = `${voice.name} (${voice.lang})`;
          html += `<option value="${voice.name}">${label}</option>`;
        });
        html += '</optgroup>';
      }

      voiceSelector.innerHTML = html;
      
      // Restore saved preference
      loadVoicePreference();
    }

    // Change voice selection
    function changeVoice() {
      const selectedVoiceName = voiceSelector.value;
      if (selectedVoiceName === '') {
        selectedVoice = null;
        saveVoicePreference('');
        console.log('Voice set to browser default');
      } else {
        const voice = availableVoices.find(v => v.name === selectedVoiceName);
        if (voice) {
          selectedVoice = voice;
          saveVoicePreference(selectedVoiceName);
          console.log('Voice changed to:', voice.name, voice.lang);
        }
      }
    }

    // Test the selected voice
    function testSelectedVoice() {
      if (!synthesis) {
        alert('Speech synthesis not available');
        return;
      }

      const testPhrases = [
        "Hi! I'm E-NOR, your robot friend!",
        "How do I sound with this voice?",
        "This is just a test to hear my new voice!"
      ];
      
      const testPhrase = testPhrases[Math.floor(Math.random() * testPhrases.length)];
      
      // Use the speak function but temporarily override the voice selection
      const originalVoice = selectedVoice;
      if (voiceSelector.value) {
        const voice = availableVoices.find(v => v.name === voiceSelector.value);
        if (voice) selectedVoice = voice;
      }
      
      speak(testPhrase).then(() => {
        selectedVoice = originalVoice; // Restore original selection
      });
    }

    // Check if speech recognition is supported
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (SpeechRecognition) {
      voiceSupported = true;
      recognition = new SpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = true; // Get interim results for better responsiveness
      recognition.lang = 'en-GB';

      recognition.onresult = handleSpeechResult;
      recognition.onerror = handleSpeechError;
      recognition.onend = handleSpeechEnd;
      recognition.onstart = () => {
        console.log('Speech recognition started');
        micPermissionGranted = true;
      };
    } else {
      voiceText.textContent = 'Voice not supported';
      micBtn.disabled = true;
    }

    function setVoiceState(state, text) {
      voiceMode = state;
      voiceStatus.className = state === 'idle' ? '' : state;
      voiceText.textContent = text;
      micBtn.classList.remove('active', 'speaking');
      if (state === 'speaking') {
        micBtn.classList.add('speaking');
      } else if (inConversation) {
        micBtn.classList.add('active');
      }
    }

    async function requestMicPermission() {
      try {
        // Request microphone permission explicitly
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        // Stop the stream immediately - we just needed permission
        stream.getTracks().forEach(track => track.stop());
        micPermissionGranted = true;
        console.log('Microphone permission granted');
        return true;
      } catch (e) {
        console.error('Microphone permission denied:', e);
        setVoiceState('idle', 'Mic denied - tap for help');
        // Show help message in chat
        showMicHelp();
        return false;
      }
    }

    function showMicHelp() {
      // Check if we already showed help
      if (document.querySelector('.mic-help-message')) return;

      const helpMsg = document.createElement('div');
      helpMsg.className = 'message system mic-help-message';
      helpMsg.innerHTML = `
        <strong>Microphone blocked!</strong> This is because the site uses HTTP, not HTTPS.<br><br>
        <strong>To fix on Chrome Android:</strong><br>
        1. Open: <code>chrome://flags</code><br>
        2. Search: "insecure origins"<br>
        3. Find: "Insecure origins treated as secure"<br>
        4. Add: <code>http://192.168.0.40:8080</code><br>
        5. Tap Enable, then Relaunch<br><br>
        <em>Or just use the text chat below!</em>
      `;
      chatMessages.appendChild(helpMsg);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    async function startListening() {
      if (!voiceSupported || !recognition) return;

      // NEVER start listening while E-NOR is speaking
      if (isSpeaking) {
        console.log('Blocked startListening - E-NOR is speaking');
        return;
      }

      // First request mic permission if not granted
      if (!micPermissionGranted) {
        const granted = await requestMicPermission();
        if (!granted) return;
      }

      try {
        recognition.start();
        setVoiceState(inConversation ? 'conversation' : 'listening', inConversation ? 'Listening...' : 'Say "Hey E-NOR"');
      } catch (e) {
        if (e.name === 'InvalidStateError') {
          // Already started, that's fine
        } else {
          console.error('Recognition start error:', e);
          setVoiceState('idle', 'Tap mic to start');
        }
      }
    }

    function stopListening() {
      if (!recognition) return;
      try {
        recognition.abort(); // Use abort() instead of stop() for immediate halt
      } catch (e) {}
    }

    function handleSpeechResult(event) {
      // Ignore speech while E-NOR is speaking (prevents echo)
      if (isSpeaking) {
        console.log('Ignoring speech - E-NOR is speaking');
        return;
      }

      const last = event.results.length - 1;
      const result = event.results[last];
      const transcript = result[0].transcript.toLowerCase().trim();

      // Log to dev console
      logSpeech(transcript, result.isFinal);

      if (!inConversation) {
        // For wake word, check on final results only
        if (result.isFinal) {
          console.log('Heard (wake check):', transcript);
          // Many phonetic variations of "Hey E-NOR"
          const wakeWords = [
            'hey e-nor', 'hey enor', 'hey e nor', 'heyeanor',
            'a nor', 'enor', 'hey nor', 'e-nor', 'eanor',
            'iy nore', 'e nore', 'ee nor', 'eenor', 'i nor',
            'inor', 'ey nor', 'ay nor', 'ae nor', 'hey noor',
            'he nor', 'henor', 'hi nor', 'hinor', 'hey nora',
            'hey ignore', 'hey in or', 'hey anna', 'inna',
            'hey naw', 'eena', 'ena', 'eenore', 'eynor',
            'hey eno', 'heyeno', 'eno', 'hey in', 'a no',
            'hey you know', 'hey no', 'hino'
          ];
          if (wakeWords.some(w => transcript.includes(w))) {
            startConversation();
          }
        }
      } else {
        // In conversation mode - buffer speech and wait for silence
        if (result.isFinal) {
          // If we're processing and user speaks more, cancel and concatenate
          if (isProcessing && pendingAbortController) {
            console.log('User spoke during processing - canceling request');
            pendingAbortController.abort();
            pendingAbortController = null;
            isProcessing = false;
            // Concatenate with previous buffer
            speechBuffer = speechBuffer ? speechBuffer + ' ' + transcript : transcript;
          } else {
            speechBuffer = transcript;
          }
          console.log('Buffered:', speechBuffer);

          // Clear any existing timeout
          if (speechTimeout) clearTimeout(speechTimeout);

          // Wait for silence before processing
          setVoiceState('conversation', 'Listening...');
          speechTimeout = setTimeout(() => {
            if (speechBuffer && !isSpeaking) {
              const textToProcess = speechBuffer;
              speechBuffer = '';
              processVoiceInput(textToProcess);
            }
          }, SILENCE_DELAY);
        } else {
          // Show interim results
          const displayText = isProcessing ? `Adding: "${transcript}..."` : `"${transcript}..."`;
          setVoiceState('conversation', displayText);
          // Reset the silence timer on interim results
          if (speechTimeout) clearTimeout(speechTimeout);

          // If processing and user starts talking, prepare to cancel
          if (isProcessing && pendingAbortController) {
            console.log('User starting to speak during processing...');
          }
        }
      }
    }

    function handleSpeechError(event) {
      console.log('Speech error:', event.error, 'isSpeaking:', isSpeaking);
      if (event.error === 'not-allowed') {
        micPermissionGranted = false;
        setVoiceState('idle', 'Tap mic for permission');
      } else if (event.error === 'no-speech') {
        // Only restart if not speaking
        if (!isSpeaking) {
          setTimeout(startListening, 500);
        }
      } else if (event.error === 'aborted') {
        // Aborted intentionally - don't restart automatically
        console.log('Speech aborted (intentional)');
      } else if (event.error === 'network') {
        setVoiceState('idle', 'Network error - tap to retry');
      }
    }

    function handleSpeechEnd() {
      console.log('Speech recognition ended, voiceMode:', voiceMode, 'isSpeaking:', isSpeaking);
      // Restart listening ONLY if not speaking
      if (!isSpeaking) {
        setTimeout(startListening, 500);
      }
    }

    async function startConversation() {
      console.log('Wake word detected! Starting conversation...');
      inConversation = true;
      setVoiceState('conversation', 'Listening...');
      applyEmotion('happy');

      // Greet the user - await to ensure speech completes before listening
      await speak("Hey! What's up?");
      console.log('Wake greeting finished');
    }

    function endConversation() {
      inConversation = false;
      setVoiceState('listening', 'Say "Hey E-NOR"');
      applyEmotion('happy');
    }

    async function processVoiceInput(text) {
      if (!text || text.length < 2) return;

      // Add user message to chat
      addMessage(text, 'user');

      // Show thinking - but KEEP listening so user can add more
      setVoiceState('conversation', 'Thinking... (keep talking to add more)');
      applyEmotion('thinking');

      // Create abort controller for this request
      pendingAbortController = new AbortController();
      isProcessing = true;

      try {
        const response = await fetch('/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message: text,
            conversation_id: conversationId
          }),
          signal: pendingAbortController.signal
        });

        const data = await response.json();
        isProcessing = false;
        pendingAbortController = null;

        // Log actions for debugging
        if (data.actions && data.actions.length > 0) {
          console.log('Actions received:', data.actions);
        }
        if (data.end_conversation) {
          console.log('End conversation flag received');
        }

        // Add to chat
        addMessage(data.response, 'enor');

        // Update emotion
        if (data.emotion && emotions[data.emotion]) {
          applyEmotion(data.emotion);
          send({ type: 'emotion', emotion: data.emotion });
        }

        // Speak the response
        await speak(data.response);

        // Check if server indicated conversation should end
        if (data.end_conversation) {
          endConversation();
        } else {
          // Continue conversation
          setVoiceState('conversation', 'Listening...');
          startListening();
        }

      } catch (error) {
        isProcessing = false;
        pendingAbortController = null;

        // Check if this was an intentional abort (user kept talking)
        if (error.name === 'AbortError') {
          console.log('Request canceled - user is still talking');
          setVoiceState('conversation', 'Listening...');
          // Don't speak error, just let the new combined text be processed
          return;
        }

        console.error('Chat error:', error);
        await speak("Sorry, my brain got confused. Can you try again?");
        applyEmotion('sad');
        setVoiceState('conversation', 'Listening...');
        startListening();
      }
    }

    function speak(text) {
      return new Promise((resolve) => {
        console.log('speak() called with:', text);

        if (!synthesis) {
          console.log('No synthesis available!');
          resolve();
          return;
        }

        // Stop listening while speaking to prevent echo
        isSpeaking = true;
        stopListening();
        speechBuffer = '';
        if (speechTimeout) clearTimeout(speechTimeout);

        // Cancel any ongoing speech and wait a moment (Chrome bug workaround)
        synthesis.cancel();

        setVoiceState('speaking', 'Speaking...');

        // Show interrupt button
        const interruptBtn = document.getElementById('interrupt-btn');
        interruptBtn.classList.add('visible');

        // Small delay after cancel (Chrome needs this)
        setTimeout(() => {
          const utterance = new SpeechSynthesisUtterance(text);
          utterance.rate = 1.0;
          utterance.pitch = 1.1;
          utterance.volume = 1.0;

          // Use selected voice or fallback to preferred voice
          let voiceToUse = selectedVoice;
          
          if (!voiceToUse) {
            const voices = synthesis.getVoices();
            console.log('No voice selected, using fallback. Available voices:', voices.length);

            voiceToUse = voices.find(v =>
              v.name.includes('Daniel') ||
              v.name.includes('Google UK English Male') ||
              v.name.includes('English United Kingdom')
            ) || voices.find(v => v.lang.startsWith('en'));
          }

          if (voiceToUse) {
            utterance.voice = voiceToUse;
            console.log('Using voice:', voiceToUse.name, '(' + voiceToUse.lang + ')');
          } else {
            console.log('No voice found, using browser default');
          }

          utterance.onstart = () => {
            console.log('Speech started:', text.substring(0, 30) + '...');
          };

          utterance.onend = () => {
            console.log('Speech ended successfully');
            isSpeaking = false;
            // Hide interrupt button
            interruptBtn.classList.remove('visible');
            // Wait a moment before resuming listening to avoid catching echo
            setTimeout(() => {
              if (inConversation && !isSpeaking) {
                setVoiceState('conversation', 'Listening...');
                startListening();
              } else if (!inConversation) {
                setVoiceState('listening', 'Say "Hey E-NOR"');
                startListening();
              }
            }, 500);
            resolve();
          };

          utterance.onerror = (e) => {
            console.error('Speech synthesis error:', e.error, e);
            isSpeaking = false;
            interruptBtn.classList.remove('visible');
            // Still try to resume listening
            setTimeout(() => {
              if (inConversation && !isSpeaking) {
                setVoiceState('conversation', 'Listening...');
                startListening();
              } else if (!inConversation) {
                setVoiceState('listening', 'Say "Hey E-NOR"');
                startListening();
              }
            }, 500);
            resolve();
          };

          console.log('Calling synthesis.speak()...');
          synthesis.speak(utterance);

          // Chrome bug: sometimes speech gets "stuck" in pending state
          // This timeout ensures we don't hang forever
          setTimeout(() => {
            if (isSpeaking && !synthesis.speaking && !synthesis.pending) {
              console.warn('Speech appears stuck, forcing resume');
              isSpeaking = false;
              interruptBtn.classList.remove('visible');
              if (inConversation) {
                setVoiceState('conversation', 'Listening...');
                startListening();
              }
              resolve();
            }
          }, 10000); // 10 second safety timeout
        }, 100); // 100ms delay after cancel
      });
    }

    function interruptSpeech() {
      if (isSpeaking && synthesis) {
        synthesis.cancel();
        isSpeaking = false;
        // Hide interrupt button
        document.getElementById('interrupt-btn').classList.remove('visible');
        if (inConversation) {
          setVoiceState('conversation', 'Listening...');
          setTimeout(() => startListening(), 300);
        }
      }
    }

    async function toggleVoiceMode() {
      if (!voiceSupported) return;

      // If speaking, interrupt
      if (isSpeaking) {
        interruptSpeech();
        return;
      }

      if (inConversation) {
        // End conversation
        speak("Okay, talk to you later!").then(() => {
          endConversation();
        });
      } else {
        // Request mic permission first if needed
        if (!micPermissionGranted) {
          const granted = await requestMicPermission();
          if (!granted) return;
        }
        // Start conversation directly
        startConversation();
      }
    }

    // ==================== Chat Panel Toggle ====================
    function toggleChatPanel() {
      document.body.classList.toggle('chat-visible');
    }

    // Tap face to show/hide chat panel
    document.getElementById('face-container').addEventListener('click', (e) => {
      // Don't toggle if clicking on settings button, versions button, or voice status
      if (e.target.closest('#settings-btn') || e.target.closest('#versions-btn') || e.target.closest('#voice-status')) return;
      toggleChatPanel();
    });

    // ==================== Startup Sequence ====================
    const startupOverlay = document.getElementById('startup-overlay');
    const startupFace = document.getElementById('startup-face');
    const startupName = document.getElementById('startup-name');
    const startupStatus = document.getElementById('startup-status');
    let voicesLoaded = false;
    let startupComplete = false;

    // Wait for voices to load (returns a promise)
    function waitForVoices() {
      return new Promise((resolve) => {
        if (!synthesis) {
          resolve();
          return;
        }

        const voices = synthesis.getVoices();
        if (voices.length > 0) {
          voicesLoaded = true;
          populateVoiceSelector(); // Populate voice selector if voices already loaded
          resolve();
          return;
        }

        // Chrome loads voices asynchronously
        speechSynthesis.onvoiceschanged = () => {
          synthesis.getVoices();
          voicesLoaded = true;
          populateVoiceSelector(); // Populate voice selector when voices load
          resolve();
        };

        // Timeout after 3 seconds in case voices never load
        setTimeout(() => {
          voicesLoaded = true;
          populateVoiceSelector(); // Try to populate even if timeout occurs
          resolve();
        }, 3000);
      });
    }

    // Run the startup sequence (~10 seconds of animation while initializing)
    async function runStartup() {
      console.log('Starting E-NOR boot sequence...');

      // Track initialization tasks (run in parallel with animation)
      let micReady = false;
      let chatReady = false;
      let initComplete = false;

      // Start all initialization tasks in background
      const initPromise = (async () => {
        console.log('Starting background initialization...');

        // Connect WebSocket
        connect();

        // Wait for voices to load
        await waitForVoices();
        console.log('Voices loaded:', voicesLoaded);

        // Check mic permission
        if (voiceSupported) {
          try {
            const permission = await navigator.permissions.query({ name: 'microphone' });
            if (permission.state === 'granted') {
              micPermissionGranted = true;
              micReady = true;
              console.log('Mic permission already granted');
            }
          } catch (err) {
            console.log('Permissions API not supported');
          }
        }

        // Keep screen awake
        if ('wakeLock' in navigator) {
          navigator.wakeLock.request('screen').catch(() => {});
          document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
              navigator.wakeLock.request('screen').catch(() => {});
            }
          });
        }

        // Check if chat is ready
        try {
          const response = await fetch('/api/chat/status');
          const data = await response.json();
          chatReady = data.ready;
          console.log('Chat ready:', chatReady);
        } catch (err) {
          console.log('Could not check chat status');
        }

        initComplete = true;
        console.log('Background initialization complete');
      })();

      // ===== PHASE 1: Initial boot (0-2s) =====
      startupStatus.textContent = 'Initializing...';
      startupStatus.classList.add('visible');
      await new Promise(r => setTimeout(r, 500));

      // Face starts to appear dimly
      startupFace.classList.add('phase1');
      await new Promise(r => setTimeout(r, 1500));

      // ===== PHASE 2: Systems coming online (2-4s) =====
      startupStatus.textContent = 'Loading systems...';
      startupFace.classList.remove('phase1');
      startupFace.classList.add('phase2');
      startupFace.classList.add('flickering');
      await new Promise(r => setTimeout(r, 1000));
      startupFace.classList.remove('flickering');
      await new Promise(r => setTimeout(r, 1000));

      // ===== PHASE 3: Face fully visible (4-6s) =====
      startupStatus.textContent = 'Activating sensors...';
      startupFace.classList.remove('phase2');
      startupFace.classList.add('visible');
      await new Promise(r => setTimeout(r, 1000));

      // Eyes "wake up" with blink
      startupFace.classList.add('waking');
      await new Promise(r => setTimeout(r, 1500));
      startupFace.classList.remove('waking');

      // ===== PHASE 4: Name reveal (6-8s) =====
      startupStatus.textContent = 'Personality loaded...';
      startupName.classList.add('visible');
      await new Promise(r => setTimeout(r, 1000));
      startupName.classList.add('glow');
      await new Promise(r => setTimeout(r, 1000));

      // ===== PHASE 5: Final checks (8-10s) =====
      startupStatus.textContent = 'Running diagnostics...';
      await new Promise(r => setTimeout(r, 1000));

      // Wait for init to complete if it hasn't already
      await initPromise;

      // Show ready status
      startupStatus.textContent = 'All systems online!';
      startupStatus.classList.add('ready');
      await new Promise(r => setTimeout(r, 1000));

      // ===== PHASE 6: Transition to main interface =====
      // Show the main face container as the overlay fades
      document.getElementById('face-container').classList.add('visible');
      startupOverlay.classList.add('hidden');
      startupComplete = true;

      // Wait for fade animation to complete
      await new Promise(r => setTimeout(r, 1000));

      // Speak the greeting
      console.log('About to speak greeting. chatReady:', chatReady, 'voicesLoaded:', voicesLoaded);
      if (chatReady && voicesLoaded) {
        try {
          await speak("Hey! I'm E-NOR, your robot friend. Just say my name when you want to chat!");
          addMessage("Hey! I'm E-NOR, your robot friend. Just say 'Hey E-NOR' when you want to chat!", 'enor');
        } catch (err) {
          console.error('Failed to speak greeting:', err);
          addMessage("Hey! I'm E-NOR, your robot friend. Just say 'Hey E-NOR' when you want to chat!", 'enor');
        }
      } else if (!chatReady) {
        addMessage("Tap the gear icon to add my Claude API key so I can chat with you!", 'system');
      } else if (!voicesLoaded) {
        console.log('Voices not loaded, skipping speech');
        addMessage("Hey! I'm E-NOR, your robot friend. Just say 'Hey E-NOR' when you want to chat!", 'enor');
      }

      // Start listening for wake word
      if (micReady) {
        startListening();
        setVoiceState('listening', 'Say "Hey E-NOR"');
      } else {
        setVoiceState('idle', 'Tap to enable voice');
        // Set up click handler for mic permission
        document.addEventListener('click', async function initVoice(e) {
          if (document.getElementById('settings-modal').contains(e.target)) return;
          if (document.getElementById('startup-overlay').contains(e.target)) return;
          if (micPermissionGranted) return;

          console.log('First click - requesting mic permission');
          const granted = await requestMicPermission();
          if (granted) {
            startListening();
          }
        }, { once: true });
      }
    }

    // Unlock audio with user gesture (required for mobile browsers)
    function unlockAudio() {
      return new Promise((resolve) => {
        if (!synthesis) {
          console.log('No synthesis available for unlock');
          resolve();
          return;
        }

        // Speak a silent/empty utterance to unlock audio
        const utterance = new SpeechSynthesisUtterance('');
        utterance.volume = 0;
        utterance.onend = () => {
          console.log('Audio unlocked successfully');
          resolve();
        };
        utterance.onerror = () => {
          console.log('Audio unlock utterance error (may be fine)');
          resolve();
        };
        synthesis.speak(utterance);

        // Also resolve after timeout in case onend doesn't fire
        setTimeout(resolve, 500);
      });
    }

    // Wait for tap, unlock audio, then start boot sequence
    const tapToStart = document.getElementById('tap-to-start');
    tapToStart.addEventListener('click', async () => {
      console.log('User tapped - unlocking audio...');

      // Unlock audio with user gesture
      await unlockAudio();

      // Hide tap-to-start overlay
      tapToStart.classList.add('hidden');

      // Wait for fade animation
      await new Promise(r => setTimeout(r, 500));

      // Start the boot sequence
      runStartup();
    }, { once: true });

    // ==================== Pending Requests ====================
    const pendingBadge = document.getElementById('pending-badge');
    const pendingCount = document.getElementById('pending-count');
    const pendingPanel = document.getElementById('pending-panel');
    const pendingOverlay = document.getElementById('pending-overlay');
    const pendingList = document.getElementById('pending-list');

    async function loadPendingRequests() {
      try {
        const response = await fetch('/api/requests');
        const data = await response.json();

        // Update badge
        const count = data.pending_count || 0;
        pendingCount.textContent = count;

        if (count > 0) {
          pendingBadge.classList.add('visible');
        } else {
          pendingBadge.classList.remove('visible');
        }

        // Update panel content
        if (data.requests && data.requests.length > 0) {
          const pendingItems = data.requests.filter(req => req.status === 'pending' || req.status === 'in_progress');
          const completedItems = data.requests.filter(req => req.status === 'completed');
          const failedItems = data.requests.filter(req => req.status === 'failed');

          let html = '';
          
          // Show pending/in-progress items first
          if (pendingItems.length > 0) {
            html += pendingItems.map(req => {
              const timeAgo = getTimeAgo(req.created_at);
              const issueLink = req.issue_number
                ? `<a href="https://github.com/martingsewell/e-nor/issues/${req.issue_number}" target="_blank" class="issue-link">#${req.issue_number}</a>`
                : '';

              return `
                <div class="pending-item">
                  <div class="title">${escapeHtml(req.title)}</div>
                  <span class="status">${req.status}</span>
                  ${issueLink}
                  <div class="time">${timeAgo}</div>
                </div>
              `;
            }).join('');
          }
          
          // Show completed items in a separate section
          if (completedItems.length > 0) {
            if (pendingItems.length > 0) {
              html += '<hr style="margin: 16px 0; border: 1px solid rgba(255,255,255,0.2);">';
              html += '<div style="color: #888; font-size: 12px; margin-bottom: 8px; text-align: center;">Recently Completed</div>';
            }
            html += completedItems.map(req => {
              const timeAgo = getTimeAgo(req.created_at);
              const issueLink = req.issue_number
                ? `<a href="https://github.com/martingsewell/e-nor/issues/${req.issue_number}" target="_blank" class="issue-link">#${req.issue_number}</a>`
                : '';

              return `
                <div class="pending-item completed">
                  <div class="title">${escapeHtml(req.title)}</div>
                  <span class="status">‚úÖ ${req.status}</span>
                  ${issueLink}
                  <div class="time">${timeAgo}</div>
                </div>
              `;
            }).join('');
          }

          // Show failed items 
          if (failedItems.length > 0) {
            if (pendingItems.length > 0 || completedItems.length > 0) {
              html += '<hr style="margin: 16px 0; border: 1px solid rgba(255,255,255,0.2);">';
              html += '<div style="color: #888; font-size: 12px; margin-bottom: 8px; text-align: center;">Failed Requests</div>';
            }
            html += failedItems.map(req => {
              const timeAgo = getTimeAgo(req.created_at);
              const issueLink = req.issue_number
                ? `<a href="https://github.com/martingsewell/e-nor/issues/${req.issue_number}" target="_blank" class="issue-link">#${req.issue_number}</a>`
                : '';

              return `
                <div class="pending-item" style="border-left: 3px solid #ff4444;">
                  <div class="title">${escapeHtml(req.title)}</div>
                  <span class="status" style="color: #ff4444;">‚ùå ${req.status}</span>
                  ${issueLink}
                  <div class="time">${timeAgo}</div>
                </div>
              `;
            }).join('');
          }

          pendingList.innerHTML = html;
        } else {
          pendingList.innerHTML = '<div id="pending-empty">No code requests yet.<br><br>Ask E-NOR for a new feature!</div>';
        }

        return data;
      } catch (error) {
        console.error('Failed to load pending requests:', error);
        return null;
      }
    }

    function getTimeAgo(isoString) {
      const date = new Date(isoString);
      const now = new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMs / 3600000);
      const diffDays = Math.floor(diffMs / 86400000);

      if (diffMins < 1) return 'just now';
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffHours < 24) return `${diffHours}h ago`;
      return `${diffDays}d ago`;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function openPendingPanel() {
      loadPendingRequests();
      pendingPanel.classList.add('visible');
      pendingOverlay.classList.add('visible');
    }

    function closePendingPanel() {
      pendingPanel.classList.remove('visible');
      pendingOverlay.classList.remove('visible');
    }

    // Check for pending requests periodically
    setInterval(loadPendingRequests, 30000); // Every 30 seconds

    // Initial load after startup
    setTimeout(loadPendingRequests, 5000);
  </script>
</body>
</html>
